var documenterSearchIndex = {"docs":
[{"location":"generation/#Grid-and-particle-generation","page":"Grid and particle generation","title":"Grid and particle generation","text":"","category":"section"},{"location":"generation/#Tesserae.generate_grid","page":"Grid and particle generation","title":"Tesserae.generate_grid","text":"generate_grid(GridProp, mesh)\n\nGenerate a background grid where each element is of type GridProp. The first field of GridProp is designated for mesh, and thus its type must match eltype(mesh). The resulting grid is a StructArray.\n\nExamples\n\njulia> struct GridProp{dim, T}\n           x  :: Vec{dim, T}\n           m  :: Float64\n           mv :: Vec{dim, T}\n           f  :: Vec{dim, T}\n           v  :: Vec{dim, T}\n           vⁿ :: Vec{dim, T}\n       end\n\njulia> grid = generate_grid(GridProp{2, Float64}, CartesianMesh(0.5, (0,3), (0,2)));\n\njulia> grid[1]\nGridProp{2, Float64}([0.0, 0.0], 0.0, [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0])\n\njulia> grid.x\n7×5 CartesianMesh{2, Float64, Vector{Float64}}:\n [0.0, 0.0]  [0.0, 0.5]  [0.0, 1.0]  [0.0, 1.5]  [0.0, 2.0]\n [0.5, 0.0]  [0.5, 0.5]  [0.5, 1.0]  [0.5, 1.5]  [0.5, 2.0]\n [1.0, 0.0]  [1.0, 0.5]  [1.0, 1.0]  [1.0, 1.5]  [1.0, 2.0]\n [1.5, 0.0]  [1.5, 0.5]  [1.5, 1.0]  [1.5, 1.5]  [1.5, 2.0]\n [2.0, 0.0]  [2.0, 0.5]  [2.0, 1.0]  [2.0, 1.5]  [2.0, 2.0]\n [2.5, 0.0]  [2.5, 0.5]  [2.5, 1.0]  [2.5, 1.5]  [2.5, 2.0]\n [3.0, 0.0]  [3.0, 0.5]  [3.0, 1.0]  [3.0, 1.5]  [3.0, 2.0]\n\njulia> grid.v\n7×5 Matrix{Vec{2, Float64}}:\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"generation/#Tesserae.generate_particles","page":"Grid and particle generation","title":"Tesserae.generate_particles","text":"generate_particles([ParticleProp], mesh; alg=PoissonDiskSampling())\n\nGenerate particles across the entire mesh domain based on the selected alg algorithm. See also GridSampling and PoissonDiskSampling.\n\nThe generated particles is a StructArray where each element is of type ParticleProp. The first field of ParticleProp is designated for particle positions.\n\njulia> ParticleProp = @NamedTuple begin\n           x  :: Vec{2, Float64}\n           m  :: Float64\n           V  :: Float64\n           v  :: Vec{2, Float64}\n           F  :: SecondOrderTensor{2, Float64, 4}\n           σ  :: SymmetricSecondOrderTensor{2, Float64, 3}\n       end\n@NamedTuple{x::Vec{2, Float64}, m::Float64, V::Float64, v::Vec{2, Float64}, F::Tensor{Tuple{2, 2}, Float64, 2, 4}, σ::SymmetricSecondOrderTensor{2, Float64, 3}}\n\njulia> mesh = CartesianMesh(0.5, (0,3), (0,2));\n\njulia> particles = generate_particles(ParticleProp, mesh; alg=GridSampling());\n\njulia> particles.F[1] = one(eltype(particles.F));\n\njulia> particles[1]\n(x = [0.125, 0.125], m = 0.0, V = 0.0, v = [0.0, 0.0], F = [1.0 0.0; 0.0 1.0], σ = [0.0 0.0; 0.0 0.0])\n\njulia> particles.F\n96-element Vector{Tensor{Tuple{2, 2}, Float64, 2, 4}}:\n [1.0 0.0; 0.0 1.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n ⋮\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0]\n\n\n\n\n\n","category":"function"},{"location":"generation/#Tesserae.GridSampling","page":"Grid and particle generation","title":"Tesserae.GridSampling","text":"GridSampling(spacing = 1/2)\n\nThe generated particles are aligned with the grid using uniform spacing. Setting spacing = 1/η will produce η^dim particles per cell, where dim is the problem dimension.\n\n\n\n\n\n","category":"type"},{"location":"generation/#Tesserae.PoissonDiskSampling","page":"Grid and particle generation","title":"Tesserae.PoissonDiskSampling","text":"PoissonDiskSampling(spacing = 1/2, rng = Random.default_rng())\n\nThe particles are generated based on the Poisson disk sampling. The spacing parameter is used to produce a similar number of particles as are generated with GridSampling.\n\n\n\n\n\n","category":"type"},{"location":"generation/","page":"Grid and particle generation","title":"Grid and particle generation","text":"(Image: )","category":"page"},{"location":"multithreading/#Multi-threading","page":"Multi-threading","title":"Multi-threading","text":"","category":"section"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"Tesserae.jl provides a @threaded macro to enable multi-threading. It behaves similarly to Julia’s built-in Threads.@threads, but is specifically designed to work with particle-grid transfer macros such as @G2P, @P2G, @G2P2G, and @P2G_Matrix.","category":"page"},{"location":"multithreading/#Usage-guidelines","page":"Multi-threading","title":"Usage guidelines","text":"","category":"section"},{"location":"multithreading/#Gathering-(@G2P)","page":"Multi-threading","title":"Gathering (@G2P)","text":"","category":"section"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"To parallelize @G2P, simply prefix it with @threaded.","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"@threaded @G2P grid=>i particles=>p weights=>ip begin\n    # your code here\nend","category":"page"},{"location":"multithreading/#Scattering-(@P2G,-@G2P2G-and-@P2G_Matrix)","page":"Multi-threading","title":"Scattering (@P2G, @G2P2G and @P2G_Matrix)","text":"","category":"section"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"For scattering operations, prefix @P2G with @threaded and use ColorPartition to avoid data races on the grid.","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"partition = ColorPartition(mesh)\nupdate!(partition, particles.x)\n@threaded @P2G grid=>i particles=>p weights=>ip partition begin\n    # your code here\nend","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"Same applies to @G2P2G and @P2G_Matrix.","category":"page"},{"location":"multithreading/#Updating-interpolation-values","page":"Multi-threading","title":"Updating interpolation values","text":"","category":"section"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"To update interpolation values, either use the update! function, or simply:","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"@threaded for p in eachindex(particles)\n    update!(weights[p], particles.x[p], mesh)\nend","category":"page"},{"location":"multithreading/#Reordering-particles","page":"Multi-threading","title":"Reordering particles","text":"","category":"section"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"For @P2G and related scattering operations, using reorder_particles! together with ColorPartition can significantly improve cache efficiency and thread scaling:","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"partition = ColorPartition(mesh)\nupdate!(partition, particles.x)\nreorder_particles!(particles, partition)","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"Reordering ensures that particles within the same grid block are stored contiguously in memory, reducing random memory access during parallel execution.","category":"page"},{"location":"multithreading/","page":"Multi-threading","title":"Multi-threading","text":"warning: Warning\nreorder_particles! can be expensive for large systems. It is usually sufficient to reorder particles only when their spatial distribution has changed significantly. Avoid calling it on every step.","category":"page"},{"location":"multithreading/#Multi-threading-API","page":"Multi-threading","title":"Multi-threading API","text":"","category":"section"},{"location":"multithreading/#Tesserae.@threaded","page":"Multi-threading","title":"Tesserae.@threaded","text":"@threaded [scheduler] for ...\n@threaded [scheduler] @P2G ...\n@threaded @P2G ...\n\nA macro similar to Threads.@threads, but also works with @P2G, @G2P, @G2P2G, and @P2G_Matrix macros for particle-grid transfers.\n\nThe optional scheduler can be :static, :dynamic, :greedy, or :nothing (sequential execution). The default is :dynamic.\n\nSee also ColorPartition.\n\nnote: Note\nIf multi-threading is disabled or only one thread is available, this macro falls back to sequential execution.\n\nExamples\n\n# Parallel loop\n@threaded for i in 1:100\n    println(i)\nend\n\n# Grid-to-particle transfer\n@threaded @G2P grid=>i particles=>p weights=>ip begin\n    v[p] = @∑ w[ip] * v[i]\nend\n\n\n\n\n\n","category":"macro"},{"location":"multithreading/#Tesserae.ColorPartition","page":"Multi-threading","title":"Tesserae.ColorPartition","text":"ColorPartition(::CartesianMesh)\n\nColorPartition stores partitioning information used by the @P2G, @G2P2G and @P2G_Matrix macros to avoid write conflicts during parallel particle-to-grid transfers.\n\nnote: Note\nThe @threaded macro must be placed before @P2G, @G2P2G and @P2G_Matrix to enable parallel transfer.\n\nExamples\n\n# Construct ColorPartition\npartition = ColorPartition(mesh)\n\n# Update coloring using current particle positions\nupdate!(partition, particles.x)\n\n# P2G transfer\n@threaded @P2G grid=>i particles=>p weights=>ip partition begin\n    m[i]  = @∑ w[ip] * m[p]\n    mv[i] = @∑ w[ip] * m[p] * v[p]\nend\n\n\n\n\n\n","category":"type"},{"location":"tutorials/collision/#Transfer-schemes","page":"Transfer schemes","title":"Transfer schemes","text":"","category":"section"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"<img src=\"https://github.com/user-attachments/assets/24cbd50c-7d21-4917-a7e1-12816b561dee\" width=\"600\"/>","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"# Particles # Iterations Execution time (w/o output)\n17k 2.9k 5 sec","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"In this example, the following velocity transfer schemes are demonstrated:","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"PIC–FLIP mixed transfer[1]\nAffine PIC (APIC)[2]\nTaylor PIC (TPIC)[3]\neXtended PIC (XPIC)[4]","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"info: Info\nIt is also recommended to refer to the manual Transfer between grid and particles.","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"The problem involves the collision between two elastic rings, which is consistent with previous study[5].","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"[1]: Stomakhin, A., Schroeder, C., Chai, L., Teran, J. and Selle, A., 2013. A material point method for snow simulation. ACM Transactions on Graphics (TOG), 32(4), pp.1-10.","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"[2]: Jiang, C., Schroeder, C., Selle, A., Teran, J. and Stomakhin, A., 2015. The affine particle-in-cell method. ACM Transactions on Graphics (TOG), 34(4), pp.1-10.","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"[3]: Nakamura, K., Matsumura, S. and Mizutani, T., 2023. Taylor particle-in-cell transfer and kernel correction for material point method. Computer Methods in Applied Mechanics and Engineering, 403, p.115720.","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"[4]: Hammerquist, C.C. and Nairn, J.A., 2017. A new method for material point method particle updates that reduces noise and enhances stability. Computer methods in applied mechanics and engineering, 318, pp.724-738.","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"[5]: Li, X., Fang, Y., Li, M. and Jiang, C., 2022. BFEMP: Interpenetration-free MPM–FEM coupling with barrier contact. Computer Methods in Applied Mechanics and Engineering, 390, p.114350.","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"using Tesserae\n\nstruct FLIP α::Float64 end\nstruct APIC end\nstruct TPIC end\nstruct XPIC m::Int end\n\nfunction main(transfer = FLIP(1.0))\n\n    # Simulation parameters\n    h   = 0.1 # Grid spacing\n    T   = 0.6 # Time span\n    CFL = 0.8 # Courant number\n\n    # Material constants\n    E  = 100e6                  # Young's modulus\n    ν  = 0.2                    # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 1e3                    # Initial density\n\n    # Geometry\n    L  = 20.0 # Length of domain\n    W  = 15.0 # Width of domain\n    rᵢ = 3.0  # Inner radius of rings\n    rₒ = 4.0  # Outer radius of rings\n\n    GridProp = @NamedTuple begin\n        x   :: Vec{2, Float64}\n        m   :: Float64\n        m⁻¹ :: Float64\n        mv  :: Vec{2, Float64}\n        f   :: Vec{2, Float64}\n        v   :: Vec{2, Float64}\n        vⁿ  :: Vec{2, Float64}\n        # XPIC\n        vᵣ★ :: Vec{2, Float64}\n        v★  :: Vec{2, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{2, Float64}\n        m  :: Float64\n        V⁰ :: Float64\n        V  :: Float64\n        v  :: Vec{2, Float64}\n        ∇v :: SecondOrderTensor{2, Float64, 4}\n        σ  :: SymmetricSecondOrderTensor{2, Float64, 3}\n        F  :: SecondOrderTensor{2, Float64, 4}\n        # APIC\n        B  :: SecondOrderTensor{2, Float64, 4}\n        # XPIC\n        vᵣ★ :: Vec{2, Float64}\n        a★  :: Vec{2, Float64}\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (-L,L), (-W/2,W/2)))\n\n    # Particles\n    particles = let\n        pts = generate_particles(ParticleProp, grid.x)\n        pts.V .= pts.V⁰ .= volume(grid.x) / length(pts)\n\n        lhs = findall(pts.x) do (x, y)\n            rᵢ^2 < (x+L/4)^2+y^2 < rₒ^2\n        end\n        rhs = findall(pts.x) do (x, y)\n            rᵢ^2 < (x-L/4)^2+y^2 < rₒ^2\n        end\n\n        # Set initial velocities\n        @. pts.v[lhs] =  Vec(30, 0)\n        @. pts.v[rhs] = -Vec(30, 0)\n\n        pts[[lhs; rhs]]\n    end\n    @. particles.m = ρ⁰ * particles.V⁰\n    @. particles.F = one(particles.F)\n    @show length(particles)\n\n    # Interpolation weights\n    weights = generate_interpolation_weights(BSpline(Quadratic()), grid.x, length(particles))\n\n    # Material model (neo-Hookean)\n    function stored_energy(C)\n        dim = size(C, 1)\n        lnJ = log(√det(C))\n        μ/2*(tr(C)-dim) - μ*lnJ + λ/2*lnJ^2\n    end\n    function cauchy_stress(F)\n        J = det(F)\n        S = 2 * gradient(stored_energy, symmetric(F'F))\n        @einsum typeof(S) (i,j) -> inv(J) * F[i,k] * S[k,l] * F[j,l]\n    end\n\n    # Outputs\n    outdir = mkpath(joinpath(\"output\", \"collision\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 120\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        # Calculate time step based on the wave speed\n        vmax = maximum(@. sqrt((λ+2μ) / (particles.m/particles.V)) + norm(particles.v))\n        Δt = CFL * h / vmax\n\n        # Update interpolation weights\n        update!(weights, particles, grid.x)\n\n        # Particle-to-grid transfer\n        if transfer isa Union{FLIP, XPIC}\n            @P2G grid=>i particles=>p weights=>ip begin\n                m[i]  = @∑ w[ip] * m[p]\n                mv[i] = @∑ w[ip] * m[p] * v[p]\n                f[i]  = @∑ -V[p] * σ[p] * ∇w[ip]\n            end\n        elseif transfer isa APIC\n            Dₚ⁻¹ = inv(1/4 * h^2 * I)\n            @P2G grid=>i particles=>p weights=>ip begin\n                m[i]  = @∑ w[ip] * m[p]\n                mv[i] = @∑ w[ip] * m[p] * (v[p] + B[p] * Dₚ⁻¹ * (x[i] - x[p]))\n                f[i]  = @∑ -V[p] * σ[p] * ∇w[ip]\n            end\n        elseif transfer isa TPIC\n            @P2G grid=>i particles=>p weights=>ip begin\n                m[i]  = @∑ w[ip] * m[p]\n                mv[i] = @∑ w[ip] * m[p] * (v[p] + ∇v[p] * (x[i] - x[p]))\n                f[i]  = @∑ -V[p] * σ[p] * ∇w[ip]\n            end\n        end\n\n        # Update grid velocity\n        @. grid.m⁻¹ = inv(grid.m) * !iszero(grid.m)\n        @. grid.vⁿ = grid.mv * grid.m⁻¹\n        @. grid.v  = grid.vⁿ + (grid.f * grid.m⁻¹) * Δt\n\n        # Grid-to-particle transfer\n        if transfer isa FLIP\n            α = transfer.α\n            @G2P grid=>i particles=>p weights=>ip begin\n                v[p]  = @∑ w[ip] * ((1-α)*v[i] + α*(v[p] + (v[i]-vⁿ[i])))\n                ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n                x[p] += @∑ w[ip] * v[i] * Δt\n            end\n        elseif transfer isa APIC\n            @G2P grid=>i particles=>p weights=>ip begin\n                v[p]  = @∑ w[ip] * v[i]\n                ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n                B[p]  = @∑ w[ip] * v[i] ⊗ (x[i] - x[p])\n                x[p] += v[p] * Δt\n            end\n        elseif transfer isa TPIC\n            @G2P grid=>i particles=>p weights=>ip begin\n                v[p]  = @∑ w[ip] * v[i]\n                ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n                x[p] += v[p] * Δt\n            end\n        elseif transfer isa XPIC\n            m = transfer.m\n            @. grid.vᵣ★ = grid.vⁿ\n            @. grid.v★ = zero(grid.v★)\n            for r in 2:m\n                @G2P grid=>i particles=>p weights=>ip begin\n                    vᵣ★[p] = @∑ w[ip] * vᵣ★[i]\n                end\n                @P2G grid=>i particles=>p weights=>ip begin\n                    vᵣ★[i] = @∑ (m-r+1)/r * w[ip] * m[p] * vᵣ★[p] * m⁻¹[i]\n                    v★[i] += (-1)^r * vᵣ★[i]\n                end\n            end\n            @G2P grid=>i particles=>p weights=>ip begin\n                ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n                a★[p] = @∑ w[ip] * (v[p] + m*(v★[i] - vⁿ[i])) / Δt\n                v[p] += @∑ w[ip] * (v[i] - vⁿ[i])\n                x[p] += @∑ w[ip] * (v[i] + vⁿ[i]) * Δt / 2\n                v[p] -= a★[p] * Δt\n                x[p] -= a★[p] * Δt^2 / 2\n            end\n        end\n\n        # Update other particle properties\n        for p in eachindex(particles)\n            ∇uₚ = particles.∇v[p] * Δt\n            Fₚ = (I + ∇uₚ) * particles.F[p]\n            σₚ = cauchy_stress(Fₚ)\n            particles.σ[p] = σₚ\n            particles.F[p] = Fₚ\n            particles.V[p] = det(Fₚ) * particles.V⁰[p]\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtm(string(pvdfile, step)) do vtm\n                    function stress3x3(F)\n                        z = zero(Vec{2})\n                        F3x3 = [F  z\n                                z' 1]\n                        cauchy_stress(F3x3)\n                    end\n                    openvtk(vtm, particles.x) do vtk\n                        vtk[\"Velocity (m/s)\"] = particles.v\n                        vtk[\"von Mises stress (MPa)\"] = @. 1e-6 * vonmises(stress3x3(particles.F))\n                    end\n                    openvtk(vtm, grid.x) do vtk\n                        vtk[\"Velocity (m/s)\"] = grid.v\n                    end\n                    pvd[t] = vtm\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"","category":"page"},{"location":"tutorials/collision/","page":"Transfer schemes","title":"Transfer schemes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"mesh/","page":"Mesh","title":"Mesh","text":"info: Info\nCurrently, only the Cartesian mesh is available.","category":"page"},{"location":"mesh/#Cartesian-mesh","page":"Mesh","title":"Cartesian mesh","text":"","category":"section"},{"location":"mesh/#Tesserae.CartesianMesh","page":"Mesh","title":"Tesserae.CartesianMesh","text":"CartesianMesh([T,] h, (xmin, xmax), (ymin, ymax)...)\n\nConstruct CartesianMesh with the spacing h.\n\nExamples\n\njulia> CartesianMesh(1.0, (0,3), (1,4))\n4×4 CartesianMesh{2, Float64, Vector{Float64}}:\n [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]\n [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]\n [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]\n [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Tesserae.spacing","page":"Mesh","title":"Tesserae.spacing","text":"spacing(::CartesianMesh)\n\nReturn the spacing of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Tesserae.volume","page":"Mesh","title":"Tesserae.volume","text":"volume(::CartesianMesh)\n\nReturn the volume of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Tesserae.extract-Union{Tuple{dim}, Tuple{CartesianMesh{dim, T} where T, Vararg{Tuple{Real, Real}, dim}}} where dim","page":"Mesh","title":"Tesserae.extract","text":"extract(mesh::CartesianMesh, (xmin, xmax), (ymin, ymax)...)\n\nExtract a portion of the mesh. The extracted mesh retains the original origin and spacing.\n\n\n\n\n\n","category":"method"},{"location":"mesh/#Tesserae.isinside","page":"Mesh","title":"Tesserae.isinside","text":"isinside(x::Vec, mesh::CartesianMesh)\n\nCheck if x is inside the mesh.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#Tesserae.whichcell","page":"Mesh","title":"Tesserae.whichcell","text":"whichcell(x::Vec, mesh::CartesianMesh)\n\nReturn the cell index where x is located.\n\nExamples\n\njulia> mesh = CartesianMesh(1, (0,5), (0,5))\n6×6 CartesianMesh{2, Float64, Vector{Float64}}:\n [0.0, 0.0]  [0.0, 1.0]  [0.0, 2.0]  [0.0, 3.0]  [0.0, 4.0]  [0.0, 5.0]\n [1.0, 0.0]  [1.0, 1.0]  [1.0, 2.0]  [1.0, 3.0]  [1.0, 4.0]  [1.0, 5.0]\n [2.0, 0.0]  [2.0, 1.0]  [2.0, 2.0]  [2.0, 3.0]  [2.0, 4.0]  [2.0, 5.0]\n [3.0, 0.0]  [3.0, 1.0]  [3.0, 2.0]  [3.0, 3.0]  [3.0, 4.0]  [3.0, 5.0]\n [4.0, 0.0]  [4.0, 1.0]  [4.0, 2.0]  [4.0, 3.0]  [4.0, 4.0]  [4.0, 5.0]\n [5.0, 0.0]  [5.0, 1.0]  [5.0, 2.0]  [5.0, 3.0]  [5.0, 4.0]  [5.0, 5.0]\n\njulia> whichcell(Vec(1.5, 1.5), mesh)\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"tutorials/tlmpm_vortex/#Total-Lagrangian-MPM","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"","category":"section"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"<img src=\"https://github.com/user-attachments/assets/84746086-8456-4bfa-b16f-a0a936fe5472\" width=\"300\"/>","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"# Particles # Iterations Execution time (w/o output)\n8k 27k 30 sec","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"This example demonstrates the total lagrangian material point method[1]. The implementation solves generalized vortex problem[1] using a linear kernel.","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"note: Note\nCurrently, the Bernstein function used in the paper[1] has not been implemented.","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"[1]: de Vaucorbeil, A., Nguyen, V.P. and Hutchinson, C.R., 2020. A Total-Lagrangian Material Point Method for solid mechanics problems involving large deformations. Computer Methods in Applied Mechanics and Engineering, 360, p.112783.","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"using Tesserae\n\nfunction main()\n\n    # Simulation parameters\n    h   = 0.02 # Grid spacing\n    T   = 1.0  # Time span\n    CFL = 0.1  # Courant number\n    α   = 0.99 # PIC-FLIP parameter\n\n    # Material constants\n    E  = 1e6                    # Young's modulus\n    ν  = 0.3                    # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 1e3                    # Initial density\n\n    # Geometry\n    Rᵢ = 0.75\n    Rₒ = 1.25\n\n    # Equations for vortex\n    G = π\n    R̄ = (Rᵢ + Rₒ) / 2\n    function calc_b_Rθ(R, t)\n        local h′′, h′, h = hessian(R -> 1-8((R-R̄)/(Rᵢ-Rₒ))^2+16((R-R̄)/(Rᵢ-Rₒ))^4, R, :all)\n        local g′′, g′, g = hessian(t -> G*sin(π*t/T), t, :all)\n        β = g * h\n        b_R = ( μ/ρ⁰*(3g*h′+R*g*h′′) - R*g′′*h)*sin(β) + (μ/ρ⁰*R*(g*h′)^2 - R*(g′*h)^2)*cos(β)\n        b_θ = (-μ/ρ⁰*(3g*h′+R*g*h′′) + R*g′′*h)*cos(β) + (μ/ρ⁰*R*(g*h′)^2 + R*(g′*h)^2)*sin(β)\n        Vec(b_R, b_θ)\n    end\n    isinside(x::Vec) = Rᵢ^2 < x⋅x < Rₒ^2\n\n    GridProp = @NamedTuple begin\n        X    :: Vec{2, Float64}\n        m    :: Float64\n        m⁻¹  :: Float64\n        mv   :: Vec{2, Float64}\n        fint :: Vec{2, Float64}\n        fext :: Vec{2, Float64}\n        b    :: Vec{2, Float64}\n        v    :: Vec{2, Float64}\n        vⁿ   :: Vec{2, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{2, Float64}\n        X  :: Vec{2, Float64}\n        m  :: Float64\n        V⁰ :: Float64\n        v  :: Vec{2, Float64}\n        ṽ  :: Vec{2, Float64}\n        ã  :: Vec{2, Float64}\n        P  :: SecondOrderTensor{2, Float64, 4}\n        F  :: SecondOrderTensor{2, Float64, 4}\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (-1.5,1.5), (-1.5,1.5)))\n    outside_gridinds = findall(!isinside, grid.X)\n\n    # Particles\n    particles = generate_particles(ParticleProp, grid.X; alg=GridSampling(spacing=1))\n    particles.V⁰ .= volume(grid.X) / length(particles)\n\n    filter!(pt->isinside(pt.x), particles)\n\n    @. particles.X = particles.x\n    @. particles.m = ρ⁰ * particles.V⁰\n    @. particles.F = one(particles.F)\n    @show length(particles)\n\n    # Precompute linear kernel weights\n    weights = generate_interpolation_weights(BSpline(Linear()), grid.X, length(particles))\n    update!(weights, particles, grid.X)\n\n    # Outputs\n    outdir = mkpath(joinpath(\"output\", \"tlmpm_vortex\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 60\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        # Calculate time step based on the wave speed\n        vmax = maximum(@. sqrt((λ+2μ) / (particles.m/(particles.V⁰ * det(particles.F)))) + norm(particles.v))\n        Δt = CFL * h / vmax\n\n        # Compute grid body forces\n        for i in eachindex(grid)\n            if isinside(grid.X[i])\n                (x, y) = grid.X[i]\n                R = sqrt(x^2 + y^2)\n                θ = atan(y, x)\n                grid.b[i] = rotmat(θ) * calc_b_Rθ(R, t)\n            end\n        end\n\n        # Particle-to-grid transfer\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]    = @∑ w[ip] * m[p]\n            mv[i]   = @∑ w[ip] * m[p] * v[p]\n            fint[i] = @∑ -V⁰[p] * P[p] * ∇w[ip]\n            fext[i] = m[i] * b[i]\n            m⁻¹[i] = inv(m[i]) * !iszero(m[i])\n            vⁿ[i]  = mv[i] * m⁻¹[i]\n            v[i]   = vⁿ[i] + ((fint[i] + fext[i]) * m⁻¹[i]) * Δt\n        end\n        grid.v[outside_gridinds] .= Ref(zero(eltype(grid.v)))\n\n        # Update particle velocity and position\n        @G2P grid=>i particles=>p weights=>ip begin\n            ṽ[p]  = @∑ w[ip] * v[i]\n            ã[p]  = @∑ w[ip] * (v[i] - vⁿ[i]) / Δt\n            v[p]  = (1-α)*ṽ[p] + α*(v[p] + ã[p]*Δt)\n            x[p] += ṽ[p] * Δt\n        end\n\n        # Remap updated velocity to grid (MUSL)\n        @P2G grid=>i particles=>p weights=>ip begin\n            mv[i] = @∑ w[ip] * m[p] * v[p]\n            v[i]  = mv[i] * m⁻¹[i]\n        end\n        grid.v[outside_gridinds] .= Ref(zero(eltype(grid.v)))\n\n        # Update stress\n        @G2P grid=>i particles=>p weights=>ip begin\n            F[p] += @∑ Δt * v[i] ⊗ ∇w[ip]\n            P[p]  = μ * (F[p] - inv(F[p])') + λ * log(det(F[p])) * inv(F[p])'\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtm(string(pvdfile, step)) do vtm\n                    angle(x) = atan(x[2], x[1])\n                    openvtk(vtm, particles.x) do vtk\n                        vtk[\"Velocity (m/s)\"] = particles.v\n                        vtk[\"Initial angle (rad)\"] = angle.(particles.X)\n                    end\n                    openvtk(vtm, grid.X) do vtk\n                        vtk[\"External force (N)\"] = grid.fext\n                    end\n                    pvd[t] = vtm\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"","category":"page"},{"location":"tutorials/tlmpm_vortex/","page":"Total Lagrangian MPM","title":"Total Lagrangian MPM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/cpdi/#A-convected-particle-domain-interpolation-technique","page":"CPDI","title":"A convected particle domain interpolation technique","text":"","category":"section"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"<img src=\"https://github.com/user-attachments/assets/86e62b20-e65d-4c23-801c-70795b774b8d\" width=\"210\"/>","category":"page"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"# Particles # Iterations Execution time (w/o output)\n27k 500 15 sec","category":"page"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"This example employs a convected particle domain interpolation[1].","category":"page"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"[1]: Sadeghirad, A., Brannon, R.M. and Burghardt, J., 2011. A convected particle domain interpolation technique to extend applicability of the material point method for problems involving massive deformations. International Journal for numerical methods in Engineering, 86(12), pp.1435-1456.","category":"page"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"using Tesserae\n\nfunction main()\n\n    # Simulation parameters\n    h  = 0.1    # Grid spacing\n    T  = 0.5    # Time span\n    Δt = 0.001  # Time step\n    g  = 1000.0 # Gravity acceleration\n\n    # Material constants\n    E = 1e6                     # Young's modulus\n    ν = 0.3                     # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 1050.0                 # Initial density\n\n    GridProp = @NamedTuple begin\n        x   :: Vec{3, Float64}\n        m   :: Float64\n        m⁻¹ :: Float64\n        mv  :: Vec{3, Float64}\n        f   :: Vec{3, Float64}\n        v   :: Vec{3, Float64}\n        vⁿ  :: Vec{3, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{3, Float64}\n        m  :: Float64\n        V⁰ :: Float64\n        v  :: Vec{3, Float64}\n        ∇v :: SecondOrderTensor{3, Float64, 9}\n        σ  :: SymmetricSecondOrderTensor{3, Float64, 6}\n        # Required in CPDI()\n        F  :: SecondOrderTensor{3, Float64, 9}\n        l  :: Float64\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (-1,1), (-3,0.5), (-1,1)))\n\n    # Particles\n    bar = extract(grid.x, (-0.5,0.5), (-1,0), (-0.5,0.5))\n    particles = generate_particles(ParticleProp, bar; alg=GridSampling(spacing=1/3))\n    particles.V⁰ .= volume(bar) / length(particles)\n    @. particles.m = ρ⁰ * particles.V⁰\n    @. particles.l = (particles.V⁰)^(1/3)\n    @. particles.F = one(particles.F)\n    @show length(particles)\n\n    # Interpolation weights\n    weights = generate_interpolation_weights(CPDI(), grid.x, length(particles))\n\n    # Material model (neo-Hookean)\n    function cauchy_stress(F)\n        J = det(F)\n        b = symmetric(F * F')\n        (μ*(b-I) + λ*log(J)*I) / J\n    end\n\n    # Outputs\n    outdir = mkpath(joinpath(\"output\", \"cpdi\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 240\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        # Update interpolation weights\n        update!(weights, particles, grid.x)\n\n        # Particle-to-grid transfer\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]  = @∑ w[ip] * m[p]\n            mv[i] = @∑ w[ip] * m[p] * v[p]\n            f[i]  = @∑ -V⁰[p] * det(F[p]) * σ[p] * ∇w[ip] + w[ip] * m[p] * Vec(0,-g,0)\n            m⁻¹[i] = inv(m[i]) * !iszero(m[i])\n            vⁿ[i]  = mv[i] * m⁻¹[i]\n            v[i]   = vⁿ[i]+ (f[i] * m⁻¹[i]) * Δt\n        end\n\n        # Boundary conditions\n        for i in eachindex(grid)\n            if grid.x[i][2] ≥ 0\n                grid.vⁿ[i] = grid.vⁿ[i] .* (true,false,true)\n                grid.v[i] = grid.v[i] .* (true,false,true)\n            end\n        end\n\n        # Grid-to-particle transfer\n        @G2P grid=>i particles=>p weights=>ip begin\n            v[p]  += @∑ w[ip] * (v[i] - vⁿ[i])\n            ∇v[p]  = @∑ v[i] ⊗ ∇w[ip]\n            x[p]  += @∑ w[ip] * v[i] * Δt\n            F[p] = (I + ∇v[p]*Δt) * F[p]\n            σ[p] = cauchy_stress(F[p])\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtm(string(pvdfile, step)) do vtm\n                    openvtk(vtm, particles.x) do vtk\n                        vtk[\"Velocity (m/s)\"] = particles.v\n                    end\n                    openvtk(vtm, grid.x) do vtk\n                    end\n                    pvd[t] = vtm\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"","category":"page"},{"location":"tutorials/cpdi/","page":"CPDI","title":"CPDI","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/heat/#Heat-problem-using-FEM","page":"Heat problem using FEM","title":"Heat problem using FEM","text":"","category":"section"},{"location":"tutorials/heat/","page":"Heat problem using FEM","title":"Heat problem using FEM","text":"<img src=\"https://github.com/user-attachments/assets/74a9fad8-da97-4ce6-8217-838fe96660ac\" width=\"400\"/>","category":"page"},{"location":"tutorials/heat/","page":"Heat problem using FEM","title":"Heat problem using FEM","text":"using Tesserae\nusing LinearAlgebra\n\nfunction main()\n\n    # Properties for grid and Gauss points\n    GridProp = @NamedTuple begin\n        x :: Vec{2, Float64} # Coordinate\n        u :: Float64         # Temperature\n        f :: Float64         # Heat source\n    end\n    PointProp = @NamedTuple begin\n        x :: Vec{2, Float64} # Coordinate\n        V :: Float64         # Weighted det(J) for Gauss–Legendre quadrature\n    end\n\n    # FEM mesh using UnstructuredMesh\n    mesh = UnstructuredMesh(CartesianMesh(0.1, (-1,1), (-1,1)))\n    grid = generate_grid(GridProp, mesh)\n\n    # Integration points\n    points = generate_particles(PointProp, mesh)\n\n    # Interpolation\n    weights = generate_interpolation_weights(mesh, size(points); name=Val(:N))\n    feupdate!(weights, mesh; volume=points.V) # Use `feupdate!` instead of `update!`\n\n    # Global matrix\n    ndofs = 1 # Degrees of freedom per node\n    K = create_sparse_matrix(mesh; ndofs)\n\n    # Create DOF map considering boundary conditions\n    dofmask = trues(ndofs, size(grid)...)\n    dofmask[1, findall(x -> x[1]==-1 || x[1]==1, mesh)] .= false\n    dofmask[1, findall(x -> x[2]==-1 || x[2]==1, mesh)] .= false\n    dofmap = DofMap(dofmask)\n\n    # Construct global vector (on grid) and matrix\n    @P2G grid=>i points=>p weights=>ip begin\n        f[i] = @∑ N[ip] * V[p]\n    end\n    @P2G_Matrix grid=>(i,j) points=>p weights=>(ip,jp) begin\n        K[i,j] = @∑ ∇N[ip] ⋅ ∇N[jp] * V[p]\n    end\n\n    # Solve the equation\n    dofmap(grid.u) .= Symmetric(extract(K, dofmap)) \\ Array(dofmap(grid.f))\n\n    # Output the results\n    openvtk(\"heat\", mesh) do vtk\n        vtk[\"Temperature\"] = grid.u\n    end\nend","category":"page"},{"location":"tutorials/heat/","page":"Heat problem using FEM","title":"Heat problem using FEM","text":"","category":"page"},{"location":"tutorials/heat/","page":"Heat problem using FEM","title":"Heat problem using FEM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/taylor_impact/#Multi-threading-simualtion","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"","category":"section"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"<img src=\"https://github.com/user-attachments/assets/cd5b926f-4613-4dd5-ac54-181c80b9d8b7\" width=\"400\"/>","category":"page"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"# Particles # Iterations Execution time (w/o output)\n1.5M 1.8k 6 min (8 threads)","category":"page"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"This example simulates a Taylor impact test using multi-threading.","category":"page"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"using Tesserae\n\nusing StableRNGs\nusing TimerOutputs\n\nfunction vonmises_model(Cᵖⁿ⁻¹, ε̄ᵖⁿ, F; λ, μ, H, τ̄y⁰)\n    κ = λ + 2μ/3                             # Bulk modulus\n    J = det(F)                               # Jacobian\n    p = κ * log(J) / J                       # Pressure\n    bᵉᵗʳ = symmetric(F * Cᵖⁿ⁻¹ * F')         # Trial left Cauchy-Green tensor\n    vals, vecs = eigen(bᵉᵗʳ)                 # Eigenvalue decomposition\n    λᵉᵗʳ = sqrt.(vals)                       # Trial stretches\n    nᵗʳₐ = (vecs[:,1], vecs[:,2], vecs[:,3]) # Principal directions\n    τ′ᵗʳ = @. 2μ*log(λᵉᵗʳ) - 2μ/3*log(J)     # Trial Kirchhoff stress\n\n    f(τ) = sqrt(3τ⋅τ/2) - (τ̄y⁰ + H*ε̄ᵖⁿ) # Yield function\n    dfdσ, fᵗʳ = gradient(f, τ′ᵗʳ, :all)\n    if fᵗʳ > 0\n        ν = τ′ᵗʳ / (sqrt(2/3) * norm(τ′ᵗʳ)) # Direction vector\n        Δγ = fᵗʳ / (3μ + H)                 # Incremental plastic multiplier\n        Δεᵖ = Δγ * dfdσ                     # Incremental logarithmic plastic stretch\n        λᵉ = @. exp(log(λᵉᵗʳ) - Δεᵖ)        # Elastic stretch\n        τ′ = τ′ᵗʳ - 2μ*Δεᵖ                  # Return map\n    else # Elastic response\n        Δγ = zero(H)\n        λᵉ = λᵉᵗʳ\n        τ′ = τ′ᵗʳ\n    end\n\n    # Update inverse of elastic left Cauchy-Green tensor\n    nₐ = nᵗʳₐ\n    bᵉ = mapreduce((λᵉ,nₐ) -> λᵉ^2 * nₐ^⊗(2), +, λᵉ, nₐ)\n\n    # Update stress\n    σ′ = τ′ / J    # Principal deviatoric Cauchy stress\n    σ  = @. σ′ + p # Principal Cauchy stress\n    σ  = mapreduce((σ,nₐ) -> σ * nₐ^⊗(2), +, σ, nₐ)\n\n    # Update state variables\n    F⁻¹ = inv(F)\n    Cᵖ⁻¹ = symmetric(F⁻¹ * bᵉ * F⁻¹') # Update plastic right Cauchy-Green tensor\n    ε̄ᵖ = ε̄ᵖⁿ + Δγ                     # Update equivalent plastic strain\n\n    σ, Cᵖ⁻¹, ε̄ᵖ\nend\n\nfunction main()\n\n    # Simulation parameters\n    T = 80e-6 # Time span\n    CFL = 0.8 # Courant number\n\n    # Material constants\n    E  = 117e9                  # Young's modulus\n    ν  = 0.35                   # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 8.93e3                 # Initial density\n    H  = 0.1e9                  # Hardening parameter\n    τ̄y⁰ = 0.4e9                 # Initial yield stress\n\n    # Geometry parameters for rod\n    R = 0.0032\n    L = 0.0324\n\n    GridProp = @NamedTuple begin\n        x  :: Vec{3, Float64}\n        m  :: Float64\n        v  :: Vec{3, Float64}\n        vⁿ :: Vec{3, Float64}\n        mv :: Vec{3, Float64}\n        f  :: Vec{3, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{3, Float64}\n        m  :: Float64\n        V  :: Float64\n        v  :: Vec{3, Float64}\n        ∇v :: SecondOrderTensor{3, Float64, 9}\n        σ  :: SymmetricSecondOrderTensor{3, Float64, 6}\n        F  :: SecondOrderTensor{3, Float64, 9}\n        c  :: Float64\n        ε̄ᵖ :: Float64\n        Cᵖ⁻¹ :: SymmetricSecondOrderTensor{3, Float64, 6}\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(R/12, (-3R,3R), (-3R,3R), (0,L+0.1L)))\n\n    # Particles\n    block = extract(grid.x, (-R,R), (-R,R), (0,L))\n    particles = generate_particles(ParticleProp, block; alg=PoissonDiskSampling(spacing=1/3, rng=StableRNG(1234)))\n    particles.V .= volume(block) / length(particles)\n    filter!(pt -> pt.x[1]^2 + pt.x[2]^2 < R^2, particles)\n    @. particles.m = ρ⁰ * particles.V\n    @. particles.F = one(particles.F)\n    @. particles.Cᵖ⁻¹ = one(particles.Cᵖ⁻¹)\n    particles.v .= Ref([0,0,-227]) # Set initial velocity\n    @show length(particles)\n\n    # Interpolation\n    weights = generate_interpolation_weights(KernelCorrection(BSpline(Quadratic())), grid.x, length(particles))\n\n    # Color partitioning for multi-threaded G2P transfer\n    if Threads.nthreads() == 1\n        partition = nothing\n    else\n        partition = ColorPartition(grid.x)\n    end\n\n    # Paraview output setup\n    outdir = mkpath(joinpath(\"output\", \"taylor_impact\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # create file\n\n    t = 0.0\n    step = 0\n    fps = 300e3\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    reset_timer!()\n    Tesserae.@showprogress while t < T\n\n        @timeit \"Update timestep\" begin\n            @threaded for p in eachindex(particles)\n                particles.c[p] = sqrt((λ+2μ) / (particles.m[p]/particles.V[p])) + norm(particles.v[p])\n            end\n            Δt::Float64 = CFL * spacing(grid.x) / maximum(particles.c)\n        end\n\n        @timeit \"Update interpolation\" begin\n            update!(weights, particles, grid.x) # Automatically uses multi-threading\n        end\n\n        if partition !== nothing\n            @timeit \"Update color partition\" begin\n                update!(partition, particles.x)\n            end\n        end\n\n        @timeit \"P2G transfer\" begin\n            @threaded @P2G grid=>i particles=>p weights=>ip partition begin\n                m[i]  = @∑ w[ip] * m[p]\n                mv[i] = @∑ w[ip] * m[p] * v[p]\n                f[i]  = @∑ -V[p] * σ[p] * ∇w[ip]\n            end\n        end\n\n        @timeit \"Grid computation\" begin\n            @. grid.vⁿ = grid.mv / grid.m * !iszero(grid.m)\n            @. grid.v  = grid.vⁿ + Δt * grid.f / grid.m * !iszero(grid.m)\n        end\n\n        @timeit \"Apply boundary conditions\" begin\n            for i in eachindex(grid)[:,:,1]\n                grid.vⁿ[i] = grid.vⁿ[i] .* (true,true,false)\n                grid.v[i] = grid.v[i] .* (true,true,false)\n            end\n        end\n\n        @timeit \"G2P transfer\" begin\n            @threaded @G2P grid=>i particles=>p weights=>ip begin\n                v[p] += @∑ w[ip] * (v[i] - vⁿ[i])\n                ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n                x[p] += @∑ w[ip] * v[i] * Δt\n            end\n        end\n\n        @timeit \"Particle computation\" begin\n            @threaded for p in eachindex(particles)\n                ΔFₚ = I + Δt*particles.∇v[p]\n                Fₚ = ΔFₚ * particles.F[p]\n                σₚ, Cᵖ⁻¹ₚ, ε̄ᵖₚ = vonmises_model(particles.Cᵖ⁻¹[p], particles.ε̄ᵖ[p], Fₚ; λ, μ, H, τ̄y⁰)\n                particles.σ[p] = σₚ\n                particles.F[p] = Fₚ\n                particles.V[p] = det(ΔFₚ) * particles.V[p]\n                particles.Cᵖ⁻¹[p] = Cᵖ⁻¹ₚ\n                particles.ε̄ᵖ[p] = ε̄ᵖₚ\n            end\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            @timeit \"Write results\" begin\n                popfirst!(savepoints)\n                openpvd(pvdfile; append=true) do pvd\n                    openvtm(string(pvdfile, step)) do vtm\n                        openvtk(vtm, particles.x) do vtk\n                            vtk[\"velocity\"] = particles.v\n                            vtk[\"plastic strain\"] = particles.ε̄ᵖ\n                        end\n                        openvtk(vtm, grid.x) do vtk\n                            vtk[\"velocity\"] = grid.v\n                        end\n                        pvd[t] = vtm\n                    end\n                end\n            end\n            if partition !== nothing\n                @timeit \"Reorder particles\" begin\n                    reorder_particles!(particles, partition)\n                end\n            end\n        end\n    end\n    print_timer()\nend","category":"page"},{"location":"tutorials/taylor_impact/#Performance","page":"Multi-threading simualtion","title":"Performance","text":"","category":"section"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"The following results were obtained using 8 threads (started with julia -t8).","category":"page"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"julia> versioninfo()\nJulia Version 1.11.5\nCommit 760b2e5b739 (2025-04-14 06:53 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin24.0.0)\n  CPU: 24 × Apple M2 Ultra\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, apple-m2)\nThreads: 8 default, 0 interactive, 4 GC (on 16 virtual cores)\n\njulia> main()\nlength(particles) = 1526888\nProgress: 100%|███████████████████████████████████████| Time: 0:07:01\n      Elapsed: 0:07:01\n   Iterations: 1,831\n        Speed: 0.18  s/it\n──────────────────────────────────────────────────────────────────────────────────────\n                                             Time                    Allocations\n                                    ───────────────────────   ────────────────────────\n         Tot / % measured:                422s /  99.7%           21.1GiB /  99.9%\n\nSection                     ncalls     time    %tot     avg     alloc    %tot      avg\n──────────────────────────────────────────────────────────────────────────────────────\nParticle computation         1.83k     229s   54.5%   125ms   12.4MiB    0.1%  6.91KiB\nWrite results                   25    79.2s   18.8%   3.17s   7.08GiB   33.5%   290MiB\nG2P transfer                 1.83k    35.7s    8.5%  19.5ms   12.8MiB    0.1%  7.14KiB\nP2G transfer                 1.83k    33.2s    7.9%  18.1ms   1.94GiB    9.2%  1.09MiB\nUpdate interpolation         1.83k    26.9s    6.4%  14.7ms   16.4MiB    0.1%  9.20KiB\nGrid computation             1.83k    9.53s    2.3%  5.21ms     0.00B    0.0%    0.00B\nUpdate timestep              1.83k    3.24s    0.8%  1.77ms   10.9MiB    0.1%  6.11KiB\nReorder particles               25    1.81s    0.4%  72.5ms   11.8GiB   55.7%   482MiB\nUpdate color partition       1.83k    1.79s    0.4%   976μs   59.1MiB    0.3%  33.0KiB\nApply boundary conditions    1.83k    126ms    0.0%  69.1μs    229MiB    1.1%   128KiB\n──────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"tutorials/taylor_impact/#Scalability","page":"Multi-threading simualtion","title":"Scalability","text":"","category":"section"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"using Plots                                             # hide\nplot(xlabel = \"Number of threads\", ylabel = \"Speedup\",  # hide\n     xlims = (0,18), ylims = (0,18), palette = :RdBu_4) # hide\nplot!([1, 2, 4, 8, 16],                                 # hide\n      93.5 ./ [93.5, 46.8, 25.6, 14.7, 8.05],           # hide\n      label = \"Update interpolation\", marker = \"o\")     # hide\nplot!([1, 2, 4, 8, 16],                                 # hide\n      108.0 ./ [108.0, 59.7, 31.9, 18.1, 12.6],         # hide\n      label = \"P2G transfer\", marker = \"o\")             # hide\nplot!([1, 2, 4, 8, 16],                                 # hide\n      145.0 ./ [145.0, 73.6, 37.6, 19.5, 11.5],         # hide\n      label = \"G2P transfer\", marker = \"o\")             # hide\nplot!([1, 2, 4, 8, 16],                                 # hide\n      915.0 ./ [915.0, 477.0, 248.0, 125.0, 66.3],      # hide\n      label = \"Particle computation\", marker = \"o\")     # hide\nplot!([1, 2, 4, 8, 16],                                 # hide\n      2331.6 ./ [2331.6, 1228.1, 649.5, 342.8, 196.9],  # hide\n      label = \"Total (w/o output)\", color = \"black\",    # hide\n      marker = \"o\")                                     # hide\nplot!([1, 17], [1, 17],                                 # hide\n      color = \"black\", linestyle = :dash,               # hide\n      label = \"\")                                       # hide","category":"page"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"","category":"page"},{"location":"tutorials/taylor_impact/","page":"Multi-threading simualtion","title":"Multi-threading simualtion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"implicit_utils/#Functionalities-for-implicit-methods","page":"Functionalities for implicit methods","title":"Functionalities for implicit methods","text":"","category":"section"},{"location":"implicit_utils/#Degrees-of-freedom-(DoF)-mapping","page":"Functionalities for implicit methods","title":"Degrees of freedom (DoF) mapping","text":"","category":"section"},{"location":"implicit_utils/#Tesserae.DofMap","page":"Functionalities for implicit methods","title":"Tesserae.DofMap","text":"DofMap(mask::AbstractArray{Bool})\n\nCreate a degree of freedom (DoF) map from a mask of size (ndofs, size(grid)...). ndofs represents the number of DoFs for a field.\n\njulia> mesh = CartesianMesh(1, (0,2), (0,1));\n\njulia> grid = generate_grid(@NamedTuple{x::Vec{2,Float64}, v::Vec{2,Float64}}, mesh);\n\njulia> grid.v .= reshape(reinterpret(Vec{2,Float64}, 1.0:12.0), 3, 2)\n3×2 Matrix{Vec{2, Float64}}:\n [1.0, 2.0]  [7.0, 8.0]\n [3.0, 4.0]  [9.0, 10.0]\n [5.0, 6.0]  [11.0, 12.0]\n\njulia> dofmask = falses(2, size(grid)...);\n\njulia> dofmask[1,1:2,:] .= true; # activate nodes\n\njulia> dofmask[:,3,2] .= true; # activate nodes\n\njulia> reinterpret(reshape, Vec{2,Bool}, dofmask)\n3×2 reinterpret(reshape, Vec{2, Bool}, ::BitArray{3}) with eltype Vec{2, Bool}:\n [1, 0]  [1, 0]\n [1, 0]  [1, 0]\n [0, 0]  [1, 1]\n\njulia> dofmap = DofMap(dofmask);\n\njulia> dofmap(grid.v)\n6-element view(reinterpret(reshape, Float64, ::Matrix{Vec{2, Float64}}), CartesianIndex{3}[CartesianIndex(1, 1, 1), CartesianIndex(1, 2, 1), CartesianIndex(1, 1, 2), CartesianIndex(1, 2, 2), CartesianIndex(1, 3, 2), CartesianIndex(2, 3, 2)]) with eltype Float64:\n  1.0\n  3.0\n  7.0\n  9.0\n 11.0\n 12.0\n\n\n\n\n\n","category":"type"},{"location":"implicit_utils/#Sparse-matrix","page":"Functionalities for implicit methods","title":"Sparse matrix","text":"","category":"section"},{"location":"implicit_utils/#Tesserae.create_sparse_matrix","page":"Functionalities for implicit methods","title":"Tesserae.create_sparse_matrix","text":"create_sparse_matrix(interpolation, mesh; ndofs = ndims(mesh))\n\nCreate a sparse matrix. Since the created matrix accounts for all nodes in the mesh, it needs to be extracted for active nodes using the DofMap. ndofs represents the number of DoFs for a field.\n\njulia> mesh = CartesianMesh(1, (0,10), (0,10));\n\njulia> A = create_sparse_matrix(BSpline(Linear()), mesh; ndofs = 1)\n121×121 SparseArrays.SparseMatrixCSC{Float64, Int64} with 961 stored entries:\n⎡⠻⣦⡀⠘⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⣀⠈⠻⣦⡀⠘⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠙⢶⣀⠈⠻⣦⡀⠙⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠙⢶⣄⠈⠻⣦⡀⠙⠷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠙⢷⣄⠈⠻⣦⡀⠉⠷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠙⢧⡄⠈⠛⣤⡀⠉⠣⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⡄⠈⠻⣦⡀⠉⠷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢦⡄⠈⠱⣦⡀⠉⠷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⡄⠈⠻⣦⡀⠙⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⣄⠈⠻⣦⡀⠙⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣄⠈⠻⣦⡀⠘⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣀⠈⠻⣦⡀⠘⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣀⠈⠻⢆⡀⠘⠳⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣀⠈⠻⣦⡀⠘⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢢⣀⠈⠛⣤⡀⠘⢳⣄⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣀⠈⠻⣦⡀⠙⢷⣄⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢶⣄⠈⠻⣦⡀⠙⠷⣄⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣄⠈⠻⣦⡀⠉⠷⣄⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⡄⠈⠻⣦⡀⠉⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⡄⠈⠻⣦⎦\n\njulia> dofmask = falses(1, size(mesh)...);\n\njulia> dofmask[:,1:3,1:3] .= true;\n\njulia> dofmap = DofMap(dofmask);\n\njulia> extract(A, dofmap)\n9×9 SparseArrays.SparseMatrixCSC{Float64, Int64} with 49 stored entries:\n 0.0  0.0   ⋅   0.0  0.0   ⋅    ⋅    ⋅    ⋅\n 0.0  0.0  0.0  0.0  0.0  0.0   ⋅    ⋅    ⋅\n  ⋅   0.0  0.0   ⋅   0.0  0.0   ⋅    ⋅    ⋅\n 0.0  0.0   ⋅   0.0  0.0   ⋅   0.0  0.0   ⋅\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n  ⋅   0.0  0.0   ⋅   0.0  0.0   ⋅   0.0  0.0\n  ⋅    ⋅    ⋅   0.0  0.0   ⋅   0.0  0.0   ⋅\n  ⋅    ⋅    ⋅   0.0  0.0  0.0  0.0  0.0  0.0\n  ⋅    ⋅    ⋅    ⋅   0.0  0.0   ⋅   0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"implicit_utils/#Tesserae.extract-Tuple{AbstractMatrix, DofMap}","page":"Functionalities for implicit methods","title":"Tesserae.extract","text":"extract(matrix::AbstractMatrix, dofmap_row::DofMap, dofmap_col::DofMap = dofmap_row)\n\nExtract the active degrees of freedom of a matrix.\n\n\n\n\n\n","category":"method"},{"location":"implicit_utils/#Assembly-of-global-matrix","page":"Functionalities for implicit methods","title":"Assembly of global matrix","text":"","category":"section"},{"location":"implicit_utils/#Tesserae.@P2G_Matrix","page":"Functionalities for implicit methods","title":"Tesserae.@P2G_Matrix","text":"@P2G_Matrix grid=>(i,j) particles=>p weights=>(ip,jp) [partition] begin\n    equations...\nend\n\nParticle-to-grid transfer macro for assembling a global matrix. A typical global stiffness matrix can be assembled as follows:\n\n@P2G_Matrix grid=>(i,j) particles=>p weights=>(ip,jp) begin\n    K[i,j] = @∑ ∇w[ip] ⊡ c[p] ⊡ ∇w[jp] * V[p]\nend\n\nwhere c and V denote the stiffness (symmetric fourth-order) tensor and the volume, respectively. It is recommended to create global stiffness K using create_sparse_matrix.\n\n\n\n\n\n","category":"macro"},{"location":"implicit_utils/#Solvers","page":"Functionalities for implicit methods","title":"Solvers","text":"","category":"section"},{"location":"implicit_utils/#Tesserae.newton!","page":"Functionalities for implicit methods","title":"Tesserae.newton!","text":"Tesserae.newton!(x::AbstractVector, f, ∇f,\n                 maxiter = 100, atol = zero(eltype(x)), rtol = sqrt(eps(eltype(x))),\n                 linsolve = (x,A,b) -> copyto!(x, A\\b), verbose = false)\n\nA simple implementation of Newton's method. The functions f(x) and ∇f(x) should return the residual vector and its Jacobian, respectively.\n\njulia> function f(x)\n           [(x[1]+3)*(x[2]^3-7)+18,\n            sin(x[2]*exp(x[1])-1)]\n       end\nf (generic function with 1 method)\n\njulia> function ∇f(x)\n           u = exp(x[1])*cos(x[2]*exp(x[1])-1)\n           [x[2]^3-7 3*x[2]^2*(x[1]+3)\n            x[2]*u   u]\n       end\n∇f (generic function with 1 method)\n\njulia> x = [0.1, 1.2];\n\njulia> issuccess = Tesserae.newton!(x, f, ∇f)\ntrue\n\njulia> x ≈ [0,1]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"tutorials/implicit_jacobian_based/#Jacobian-based-implicit-method","page":"Jacobian-based","title":"Jacobian-based implicit method","text":"","category":"section"},{"location":"tutorials/implicit_jacobian_based/","page":"Jacobian-based","title":"Jacobian-based","text":"<img src=\"https://github.com/user-attachments/assets/81697408-0975-49aa-959e-f885ccea98b2\" width=\"300\"/>","category":"page"},{"location":"tutorials/implicit_jacobian_based/","page":"Jacobian-based","title":"Jacobian-based","text":"# Particles # Iterations Execution time (w/o output)\n600 300 2 sec","category":"page"},{"location":"tutorials/implicit_jacobian_based/","page":"Jacobian-based","title":"Jacobian-based","text":"using Tesserae\nusing LinearAlgebra\n\nfunction main()\n\n    # Simulation parameters\n    h  = 0.25 # Grid spacing\n    T  = 3.0  # Time span\n    g  = 10.0 # Gravity acceleration\n    Δt = 0.01 # Time step\n\n    # Material constants\n    E  = 1e6                    # Young's modulus\n    ν  = 0.3                    # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 1050.0                 # Density\n\n    # Newmark-beta integration\n    β = 1/4\n    γ = 1/2\n\n    GridProp = @NamedTuple begin\n        X   :: Vec{2, Float64}\n        m   :: Float64\n        m⁻¹ :: Float64\n        v   :: Vec{2, Float64}\n        vⁿ  :: Vec{2, Float64}\n        mv  :: Vec{2, Float64}\n        a   :: Vec{2, Float64}\n        aⁿ  :: Vec{2, Float64}\n        ma  :: Vec{2, Float64}\n        u   :: Vec{2, Float64}\n        f   :: Vec{2, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x    :: Vec{2, Float64}\n        m    :: Float64\n        V⁰   :: Float64\n        v    :: Vec{2, Float64}\n        a    :: Vec{2, Float64}\n        b    :: Vec{2, Float64}\n        ∇u   :: SecondOrderTensor{2, Float64, 4}\n        F    :: SecondOrderTensor{2, Float64, 4}\n        ΔF⁻¹ :: SecondOrderTensor{2, Float64, 4}\n        τ    :: SecondOrderTensor{2, Float64, 4}\n        ℂ    :: FourthOrderTensor{2, Float64, 16}\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (-1,5), (-5,1)))\n\n    # Particles\n    beam = extract(grid.X, (0,4), (0,1))\n    particles = generate_particles(ParticleProp, beam; alg=GridSampling(spacing=1/3))\n    particles.V⁰ .= volume(beam) / length(particles)\n    @. particles.m = ρ⁰ * particles.V⁰\n    @. particles.F = one(particles.F)\n    @. particles.b = Vec(0,-g)\n    @show length(particles)\n\n    # Interpolation\n    # Use the kernel correction to properly handle the boundary conditions\n    interp = KernelCorrection(BSpline(Quadratic()))\n    weights = generate_interpolation_weights(interp, grid.X, length(particles))\n\n    # Neo-Hookean model\n    function kirchhoff_stress(F)\n        J = det(F)\n        b = symmetric(F * F')\n        μ*(b-I) + λ*log(J)*I\n    end\n\n    # Sparse matrix\n    A = create_sparse_matrix(interp, grid.X)\n\n    # Outputs\n    outdir = mkpath(joinpath(\"output\", \"implicit_jacobian_based\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 60\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        activenodes = trues(size(grid))\n        for i in eachindex(grid)\n            if grid.X[i][1] < 0 && grid.X[i][2] > -(1+2h)\n                activenodes[i] = false\n            end\n        end\n        update!(weights, particles, grid.X, activenodes)\n\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]  = @∑ w[ip] * m[p]\n            mv[i] = @∑ w[ip] * m[p] * v[p]\n            ma[i] = @∑ w[ip] * m[p] * a[p]\n        end\n\n        # Compute the grid velocity and acceleration at t = tⁿ\n        @. grid.m⁻¹ = inv(grid.m) * !iszero(grid.m)\n        @. grid.vⁿ = grid.mv * grid.m⁻¹\n        @. grid.aⁿ = grid.ma * grid.m⁻¹\n\n        # Create dofmask\n        dofmask = trues(2, size(grid)...)\n        for i in eachindex(grid)\n            iszero(grid.m[i]) && (dofmask[:,i] .= false)\n        end\n\n        # Update boundary conditions and dofmap\n        @. grid.u = zero(grid.u)\n        for i in eachindex(grid)\n            if grid.X[i][1] ≤ 0 && grid.X[i][2] > -(1+2h)\n                dofmask[:,i] .= false\n            end\n        end\n        dofmap = DofMap(dofmask)\n\n        # Solve the nonlinear equation\n        state = (; grid, particles, weights, kirchhoff_stress, β, γ, A, dofmap, Δt)\n        U = copy(dofmap(grid.u)) # Convert grid data to plain vector data\n        compute_residual(U) = residual(U, state)\n        compute_jacobian(U) = jacobian(U, state)\n        Tesserae.newton!(U, compute_residual, compute_jacobian)\n\n        # Grid dispacement, velocity and acceleration have been updated during Newton's iterations\n        @G2P grid=>i particles=>p weights=>ip begin\n            ∇u[p] = @∑ u[i] ⊗ ∇w[ip]\n            a[p]  = @∑ w[ip] * a[i]\n            v[p] += @∑ w[ip] * ((1-γ)*a[p] + γ*a[i]) * Δt\n            x[p]  = @∑ w[ip] * (X[i] + u[i])\n            F[p]  = (I + ∇u[p]) * F[p]\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtk(string(pvdfile, step), particles.x) do vtk\n                    function stress3x3(F)\n                        z = zero(Vec{2})\n                        F3x3 = [F  z\n                                z' 1]\n                        kirchhoff_stress(F3x3) * inv(det(F3x3))\n                    end\n                    vtk[\"Velocity (m/s)\"] = particles.v\n                    vtk[\"von Mises stress (kPa)\"] = @. 1e-3 * vonmises(stress3x3(particles.F))\n                    pvd[t] = vtk\n                end\n            end\n        end\n    end\nend\n\nfunction residual(U::AbstractVector, state)\n    (; grid, particles, weights, kirchhoff_stress, β, γ, dofmap, Δt) = state\n\n    dofmap(grid.u) .= U\n    @. grid.a = (1/(β*Δt^2))*grid.u - (1/(β*Δt))*grid.vⁿ - (1/2β-1)*grid.aⁿ\n    @. grid.v = grid.vⁿ + ((1-γ)*grid.aⁿ + γ*grid.a) * Δt\n\n    geometric(τ) = @einsum (i,j,k,l) -> τ[i,l] * one(τ)[j,k]\n    @G2P2G grid=>i particles=>p weights=>ip begin\n        # In addition to updating the stress tensor, the stiffness tensor,\n        # which is utilized in the Jacobian-vector product, is also updated.\n        ∇u[p] = @∑ u[i] ⊗ ∇w[ip]\n        ΔF⁻¹[p] = inv(I + ∇u[p])\n        F = (I + ∇u[p]) * F[p]\n        ∂τ∂F, τ = gradient(kirchhoff_stress, F, :all)\n        τ[p] = τ\n        ℂ[p] = ∂τ∂F ⊡ F' - geometric(τ)\n        f[i] = @∑ V⁰[p] * τ[p] * (∇w[ip] ⊡ ΔF⁻¹[p]) - w[ip] * m[p] * b[p]\n    end\n\n    @. $dofmap(grid.m) * $dofmap(grid.a) + $dofmap(grid.f)\nend\n\nfunction jacobian(U::AbstractVector, state)\n    (; grid, particles, weights, β, A, dofmap, Δt) = state\n\n    dotdot(a,ℂ,b) = @einsum (i,j) -> a[k] * ℂ[i,k,j,l] * b[l]\n    @P2G_Matrix grid=>(i,j) particles=>p weights=>(ip,jp) begin\n        A[i,j] = @∑ dotdot(∇w[ip] ⊡ ΔF⁻¹[p], ℂ[p], ∇w[jp] ⊡ ΔF⁻¹[p]) * V⁰[p]\n    end\n\n    extract(A, dofmap) + Diagonal(inv(β*Δt^2) * dofmap(grid.m))\nend","category":"page"},{"location":"tutorials/implicit_jacobian_based/","page":"Jacobian-based","title":"Jacobian-based","text":"","category":"page"},{"location":"tutorials/implicit_jacobian_based/","page":"Jacobian-based","title":"Jacobian-based","text":"This page was generated using Literate.jl.","category":"page"},{"location":"implicit/#Implicit-formulation","page":"Implicit formulation","title":"Implicit formulation","text":"","category":"section"},{"location":"implicit/#Residual-vector-and-Jacobian-matrix","page":"Implicit formulation","title":"Residual vector and Jacobian matrix","text":"","category":"section"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"In MPM, since the momentum equation is solved on the grid, the residual vector bmR for solving nonlinear equations can be expressed as:","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"bmR_I(bmu_I^n+1) = m_I bma_I(bmu_I^n+1) + bmf_I(bmu_I^n+1)","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"where","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"bmf_I\n= sum_p V_p bmsigma_p fracpartial w_Ippartial bmx\n= sum_p V_p^0 bmtau_p fracpartial w_Ippartial bmx","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"Using the Newmark-beta method, the grid velocity and acceleration can be written as:","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"beginaligned\nbmv_I^n+1 = fracgammabetaDeltat bmu_I^n+1 - left( fracgammabeta - 1 right) bmv_I^n - Deltat left( fracgamma2beta - 1right) bma_I^n \nbma_I^n+1 = frac1betaDeltat^2 bmu_I^n+1 - frac1betaDeltat bmv_I^n - left( frac12beta -1 right) bma_I^n\nendaligned","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"The linearization of the residual vector is given by:","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"deltabmR_I = m_I fracpartialbma_I^n+1partialbmu_J^n+1 deltabmu_J + fracpartialbmf_I^n+1partialbmu_J^n+1 deltabmu_J","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"where","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"beginaligned\nleft( fracpartialbma_I^n+1partialbmu_J^n+1 right)_ij = fracdelta_IJbetaDeltat^2 delta_ij \nleft( fracpartialbmf_I^n+1partialbmu_J^n+1 right)_ij = sum_p fracpartial w_Ippartial x_k left(mathbbC_pright)_ikjl fracpartial w_Jppartial x_l V_p^0\nendaligned","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"The spatial tangent modulus mathbbC is defined as:","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"mathbbC_ijkl = fracpartial tau_ijpartial F_km F_lm - tau_ildelta_jk","category":"page"},{"location":"implicit/#The-derivative-of-the-basis-function[1]","page":"Implicit formulation","title":"The derivative of the basis function[1]","text":"","category":"section"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"In the implicit formulation, the derivative of the basis function nabla_bmxw must be evaluated based on the current configuration. However, in MPM, this is not feasible because the basis function and its derivative are defined on the coordinates at the beginning of each time step, bmX. Thus the derivative of the basis function with respect to the current coordinates bmx should be computed using","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"[1]: Charlton, T.J., Coombs, W.M. and Augarde, C.E., 2017. iGIMP: An implicit generalised interpolation material point method for large deformations. Computers & Structures, 190, pp.108-125.","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"fracpartial wpartial x_j\n= fracpartial wpartial X_i fracpartial X_ipartial x_j\n= fracpartial wpartial X_i DeltaF_ij^-1","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"where","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"DeltaF_ij\n= fracpartial x_ipartial X_j\n= delta_ij + fracpartial u_ipartial X_j","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"This relative deformation gradient DeltabmF is typically used to update the deformation gradient in MPM:","category":"page"},{"location":"implicit/","page":"Implicit formulation","title":"Implicit formulation","text":"F_ij = DeltaF_ik F_kj^n","category":"page"},{"location":"interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"interpolation/#Tesserae.update!-Tuple{AbstractArray{<:InterpolationWeight}, StructArrays.StructArray, Tesserae.AbstractMesh, AbstractArray}","page":"Interpolation","title":"Tesserae.update!","text":"update!(weights, particles, mesh)\n\nUpdates each element in weights using particle data and the background mesh. Automatically dispatches to CPU or GPU backend with appropriate parallelization.\n\nThis is functionally equivalent to:\n\nfor p in eachindex(particles)\n    update!(weights[p], LazyRow(particles, p), mesh)\nend\n\nwhere LaxyRow is provided in StructArrays.jl.\n\n\n\n\n\n","category":"method"},{"location":"interpolation/#Interpolation-types","page":"Interpolation","title":"Interpolation types","text":"","category":"section"},{"location":"interpolation/#Tesserae.BSpline","page":"Interpolation","title":"Tesserae.BSpline","text":"BSpline(degree)\n\nB-spline kernel. degree is one of Linear(), Quadratic() or Cubic().\n\nwarning: Warning\nBSpline(Quadratic()) and BSpline(Cubic()) cannot handle boundaries correctly because the kernel values are merely truncated, which leads to unstable behavior. Therefore, it is recommended to use either SteffenBSpline or KernelCorrection in cases where proper handling of boundaries is necessary.\n\n\n\n\n\n","category":"type"},{"location":"interpolation/#Tesserae.SteffenBSpline","page":"Interpolation","title":"Tesserae.SteffenBSpline","text":"SteffenBSpline(degree)\n\nB-spline kernel with boundary correction by Steffen et al.[Steffen] SteffenBSpline satisfies the partition of unity, sum_i w_ip = 1, near boundaries. See also KernelCorrection.\n\n[Steffen]: Steffen, M., Kirby, R. M., & Berzins, M. (2008). Analysis and reduction of quadrature errors in the material point method (MPM). International journal for numerical methods in engineering, 76(6), 922-948.\n\n\n\n\n\n","category":"type"},{"location":"interpolation/#Tesserae.uGIMP","page":"Interpolation","title":"Tesserae.uGIMP","text":"uGIMP()\n\nA kernel for the unchanged generalized interpolation material point (uGIMP) [GIMP]. uGIMP requires the initial particle length l in the particle property as follows:\n\nParticleProp = @NamedTuple begin\n    < variables... >\n    l :: Float64\nend\n\n[GIMP]: Bardenhagen, S. G., & Kober, E. M. (2004). The generalized interpolation material point method. Computer Modeling in Engineering and Sciences, 5(6), 477-496.\n\n\n\n\n\n","category":"type"},{"location":"interpolation/#Tesserae.CPDI","page":"Interpolation","title":"Tesserae.CPDI","text":"CPDI()\n\nA kernel for convected particle domain interpolation (CPDI) [CPDI]. CPDI requires the initial particle length l and the deformation gradient F in the particle property. For example, in two dimensions, the property is likely to be as follows:\n\nParticleProp = @NamedTuple begin\n    < variables... >\n    l :: Float64\n    F :: Mat{2, 2, Float64, 4}\nend\n\n[CPDI]: Sadeghirad, A., Brannon, R.M. and Burghardt, J., 2011. A convected particle domain interpolation technique to extend applicability of the material point method for problems involving massive deformations. International Journal for numerical methods in Engineering, 86(12), pp.1435-1456.\n\n\n\n\n\n","category":"type"},{"location":"interpolation/#Tesserae.WLS","page":"Interpolation","title":"Tesserae.WLS","text":"WLS(kernel)\n\nWLS performs a local weighted least squares fit for the kernel. This results in the same kernel used in moving least squares MPM[MLSMPM]. kernel is one of BSpline and uGIMP.\n\n[MLSMPM]: Hu, Y., Fang, Y., Ge, Z., Qu, Z., Zhu, Y., Pradhana, A. and Jiang, C., 2018. A moving least squares material point method with displacement discontinuity and two-way rigid body coupling. ACM Transactions on Graphics (TOG), 37(4), pp.1-14.\n\n\n\n\n\n","category":"type"},{"location":"interpolation/#Tesserae.KernelCorrection","page":"Interpolation","title":"Tesserae.KernelCorrection","text":"KernelCorrection(kernel)\n\nKernelCorrection[KC] modifies kernel to achieve stable simulations near boundaries. The corrected kernel satisfies not only the partition of unity, sum_i w_ip = 1, but also the linear field reproduction, sum_i w_ip bmx_i = bmx_p, near boundaries. In the implementation, this simply applies WLS near boundaries. kernel is one of BSpline and uGIMP. See also SteffenBSpline.\n\n[KC]: Nakamura, K., Matsumura, S., & Mizutani, T. (2023). Taylor particle-in-cell transfer and kernel correction for material point method. Computer Methods in Applied Mechanics and Engineering, 403, 115720.\n\n\n\n\n\n","category":"type"},{"location":"interpolation/#Interpolation-weight","page":"Interpolation","title":"Interpolation weight","text":"","category":"section"},{"location":"interpolation/#Tesserae.InterpolationWeight","page":"Interpolation","title":"Tesserae.InterpolationWeight","text":"InterpolationWeight([T,] interpolation, mesh)\n\nInterpolationWeight stores interpolation data, such as basis function values and their spatial derivatives.\n\njulia> mesh = CartesianMesh(1.0, (0,5), (0,5));\n\njulia> xₚ = Vec(2.2, 3.4); # particle position\n\njulia> iw = InterpolationWeight(BSpline(Quadratic()), mesh);\n\njulia> update!(iw, xₚ, mesh) # update `iw` at position `xₚ` in `mesh`\nInterpolationWeight:\n  Interpolation: BSpline(Quadratic())\n  Property names: w::Matrix{Float64}, ∇w::Matrix{Vec{2, Float64}}\n  Neighboring nodes: CartesianIndices((2:4, 3:5))\n\njulia> sum(iw.w) ≈ 1 # partition of unity\ntrue\n\njulia> nodeindices = neighboringnodes(iw) # grid indices within a particles' local domain\nCartesianIndices((2:4, 3:5))\n\njulia> sum(eachindex(nodeindices)) do ip # linear field reproduction\n           i = nodeindices[ip]\n           iw.w[ip] * mesh[i]\n       end ≈ xₚ\ntrue\n\n\n\n\n\n","category":"type"},{"location":"tutorials/rigid_body_contact/#Frictional-contact-with-rigid-body","page":"Frictional contact with rigid body","title":"Frictional contact with rigid body","text":"","category":"section"},{"location":"tutorials/rigid_body_contact/","page":"Frictional contact with rigid body","title":"Frictional contact with rigid body","text":"<img src=\"https://github.com/user-attachments/assets/35e4744f-90ee-475d-bdb7-73f94fb28369\" width=\"300\"/>","category":"page"},{"location":"tutorials/rigid_body_contact/","page":"Frictional contact with rigid body","title":"Frictional contact with rigid body","text":"# Particles # Iterations Execution time (w/o output)\n14k 220k 6 min","category":"page"},{"location":"tutorials/rigid_body_contact/","page":"Frictional contact with rigid body","title":"Frictional contact with rigid body","text":"using Tesserae\n\nmutable struct Disk{dim, T}\n    x::Vec{dim, T}\n    v::Vec{dim, T}\nend\n\nfunction main()\n\n    # Simulation parameters\n    h   = 0.004 # Grid spacing\n    T   = 5.0   # Time span\n    g   = 9.81  # Gravity acceleration\n    CFL = 1.0   # Courant number\n\n    # Material constants\n    E  = 1e6                    # Young's modulus\n    ν  = 0.49                   # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    G  = E / 2(1 + ν)           # Shear modulus\n    σy = 1e3                    # Yield stress\n    ρ⁰ = 1e3                    # Initial density\n\n    # Disk\n    D = 0.04\n    disk = Disk(Vec(0, 7.5D), Vec(0, -0.25D))\n\n    # Contact parameters\n    k = 1e6 # Penalty coefficient\n    μ = 0.6 # Friction coefficient\n\n    # Utils\n    @inline function contact_force_normal(x, r, x_disk)\n        d = x - x_disk\n        k * max(D/2 - (norm(d)-r), 0) * normalize(d)\n    end\n    @inline function contact_force_tangent(fₙ, v, m, Δt)\n        iszero(fₙ) && return zero(fₙ)\n        n = normalize(fₙ)\n        fₜ = -m * (v-(v⋅n)*n) / Δt # Sticking force\n        min(1, μ*norm(fₙ)/norm(fₜ)) * fₜ\n    end\n\n    # Properties for grid and particles\n    GridProp = @NamedTuple begin\n        x    :: Vec{2, Float64}\n        m    :: Float64\n        m⁻¹  :: Float64\n        mv   :: Vec{2, Float64}\n        fint :: Vec{2, Float64}\n        fext :: Vec{2, Float64}\n        v    :: Vec{2, Float64}\n        vⁿ   :: Vec{2, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{2, Float64}\n        m  :: Float64\n        V  :: Float64\n        r  :: Float64\n        v  :: Vec{2, Float64}\n        ∇v :: SecondOrderTensor{2, Float64, 4}\n        F  :: SecondOrderTensor{3, Float64, 9}\n        σ  :: SymmetricSecondOrderTensor{3, Float64, 6}\n        ε  :: SymmetricSecondOrderTensor{3, Float64, 6}\n        b  :: Vec{2, Float64}\n    end\n\n    # Background grid\n    H = 7D   # Ground height\n    grid = generate_grid(GridProp, CartesianMesh(h, (0,5D), (0,H+D)))\n\n    # Particles\n    particles = generate_particles(ParticleProp, grid.x)\n    disk_points = filter(particles.x) do (x,y) # Points representing a disk just for visualization\n        x^2 + (y-7.5D)^2 < (D/2)^2\n    end\n    particles.V .= volume(grid.x) / length(particles)\n    filter!(pt -> pt.x[2] < H, particles)\n    @. particles.m = ρ⁰ * particles.V\n    @. particles.r = particles.V^(1/2) / 2\n    @. particles.b = Vec(0,-g)\n    @. particles.F = one(particles.F)\n    for p in eachindex(particles)\n        x, y = particles.x[p]\n        σ_y = -ρ⁰ * g * (H - y)\n        σ_x = ν/(1-ν) * σ_y\n        particles.σ[p] = [σ_x 0.0 0.0\n                          0.0 σ_y 0.0\n                          0.0 0.0 σ_x]\n    end\n    @show length(particles)\n\n    # Interpolation\n    weights = generate_interpolation_weights(KernelCorrection(BSpline(Quadratic())), grid.x, length(particles))\n\n    # Output\n    outdir = mkpath(joinpath(\"output\", \"rigid_body_contact\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 20\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        vmax = maximum(@. sqrt((λ+2G) / (particles.m/particles.V)) + norm(particles.v))\n        Δt = CFL * h / vmax\n\n        # Update interpolation values\n        update!(weights, particles, grid.x)\n\n        # Particle-to-grid transfer\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]  = @∑ w[ip] * m[p]\n            mv[i] = @∑ w[ip] * m[p] * (v[p] + ∇v[p] * (x[i] - x[p])) # Taylor transfer\n            fint[i] = @∑ -V[p] * resize(σ[p], (2,2)) * ∇w[ip] + w[ip] * m[p] * b[p]\n            fext[i] = @∑ w[ip] * contact_force_normal(x[p], r[p], disk.x)\n            m⁻¹[i] = inv(m[i]) * !iszero(m[i])\n            vⁿ[i]  = mv[i] * m⁻¹[i]\n            v[i]   = vⁿ[i] + (fint[i] * m⁻¹[i]) * Δt\n            fext[i] += contact_force_tangent(fext[i], v[i]-$Ref(disk.v), m[i], Δt)\n            v[i]    += (fext[i] * m⁻¹[i]) * Δt\n        end\n\n        # Boundary conditions\n        for i in eachindex(grid)[[begin,end],:]\n            grid.v[i] = grid.v[i] .* (false,true)\n        end\n        for i in eachindex(grid)[:,[begin,end]]\n            grid.v[i] = grid.v[i] .* (false,false)\n        end\n\n        # Grid-to-particle transfer\n        @G2P grid=>i particles=>p weights=>ip begin\n            v[p]  = @∑ w[ip] * v[i] # PIC transfer\n            ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n            x[p] += v[p] * Δt\n            ∇uₚ = resize(∇v[p], (3,3)) * Δt\n            σ[p] = vonmises_model(σ[p], ∇uₚ; λ, G, σy)\n            V[p] *= det(I + ∇uₚ)\n            ε[p] += symmetric(∇uₚ)\n        end\n\n        disk.x += disk.v * Δt\n        disk_points .+= Ref(disk.v * Δt)\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtm(string(pvdfile, step)) do vtm\n                    deviatoric_strain(ε) = sqrt(2/3 * dev(ε) ⊡₂ dev(ε))\n                    openvtk(vtm, particles.x) do vtk\n                        vtk[\"von Mises stress (kPa)\"] = @. 1e-3 * vonmises(particles.σ)\n                        vtk[\"Deviatoric strain\"] = @. deviatoric_strain(particles.ε)\n                    end\n                    openvtk(vtm, disk_points) do vtk\n                    end\n                    pvd[t] = vtm\n                end\n            end\n        end\n    end\nend\n\nfunction vonmises_model(σⁿ, ∇u; λ, G, σy)\n    δ = one(SymmetricSecondOrderTensor{3})\n    I = one(SymmetricFourthOrderTensor{3})\n    cᵉ = λ*δ⊗δ + 2G*I\n    σᵗʳ = σⁿ + cᵉ ⊡₂ symmetric(∇u) + 2*symmetric(σⁿ * skew(∇u)) # Consider Jaumann stress-rate\n    dfdσ, fᵗʳ = gradient(σ -> vonmises(σ) - σy, σᵗʳ, :all)\n    if fᵗʳ > 0\n        dλ = fᵗʳ / (dfdσ ⊡₂ cᵉ ⊡₂ dfdσ)\n        σ = σᵗʳ - cᵉ ⊡₂ (dλ * dfdσ)\n    else\n        σ = σᵗʳ\n    end\n    if tr(σ)/3 > 0 # simple tension cut-off\n        σ = dev(σ)\n    end\n    σ\nend","category":"page"},{"location":"tutorials/rigid_body_contact/","page":"Frictional contact with rigid body","title":"Frictional contact with rigid body","text":"","category":"page"},{"location":"tutorials/rigid_body_contact/","page":"Frictional contact with rigid body","title":"Frictional contact with rigid body","text":"This page was generated using Literate.jl.","category":"page"},{"location":"transfer/#manual","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"","category":"section"},{"location":"transfer/#Transfer-macros","page":"Transfer between grid and particles","title":"Transfer macros","text":"","category":"section"},{"location":"transfer/#Tesserae.@P2G","page":"Transfer between grid and particles","title":"Tesserae.@P2G","text":"@P2G grid=>i particles=>p weights=>ip [partition] begin\n    equations...\nend\n\nParticle-to-grid transfer macro. Based on the parent => index expressions, a[index] in equations translates to parent.a[index]. This index can be replaced with any other name.\n\nExamples\n\n@P2G grid=>i particles=>p weights=>ip begin\n\n    # Particle-to-grid transfer\n    m[i]  = @∑ w[ip] * m[p]\n    mv[i] = @∑ w[ip] * m[p] * v[p]\n    f[i]  = @∑ -V[p] * σ[p] * ∇w[ip]\n\n    # Calculation on grid\n    vⁿ[i] = mv[i] / m[i]\n    v[i]  = vⁿ[i] + (f[i] / m[i]) * Δt\n\nend\n\nThis expands to roughly the following code:\n\n# Reset grid properties\n@. grid.m  = zero(grid.m)\n@. grid.mv = zero(grid.mv)\n@. grid.f  = zero(grid.f)\n\n# Particle-to-grid transfer\nfor p in eachindex(particles)\n    iw = weights[p]\n    nodeindices = neighboringnodes(iw)\n    for ip in eachindex(nodeindices)\n        i = nodeindices[ip]\n        grid.m [i] += iw.w[ip] * particles.m[p]\n        grid.mv[i] += iw.w[ip] * particles.m[p] * particles.v[p]\n        grid.mv[i] += -particles.V[p] * particles.σ[p] * iw.∇w[ip]\n    end\nend\n\n# Calculation on grid\n@. grid.vⁿ = grid.mv / grid.m\n@. grid.v  = grid.vⁿ + (grid.f / grid.m) * Δt\n\nwarning: Warning\nIn @P2G, Calculation on grid part must be placed after Particle-to-grid transfer part.\n\n\n\n\n\n","category":"macro"},{"location":"transfer/#Tesserae.@G2P","page":"Transfer between grid and particles","title":"Tesserae.@G2P","text":"@G2P grid=>i particles=>p weights=>ip begin\n    equations...\nend\n\nGrid-to-particle transfer macro. Based on the parent => index expressions, a[index] in equations translates to parent.a[index]. This index can be replaced with any other name.\n\nExamples\n\n@G2P grid=>i particles=>p weights=>ip begin\n\n    # Grid-to-particle transfer\n    v[p] += @∑ w[ip] * (vⁿ[i] - v[i])\n    ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n    x[p] += @∑ w[ip] * v[i] * Δt\n\n    # Calculation on particle\n    Δϵₚ = symmetric(∇v[p]) * Δt\n    F[p]  = (I + ∇v[p]*Δt) * F[p]\n    V[p]  = V⁰[p] * det(F[p])\n    σ[p] += λ*tr(Δϵₚ)*I + 2μ*Δϵₚ # Linear elastic material\n\nend\n\nThis expands to roughly the following code:\n\n# Grid-to-particle transfer\nfor p in eachindex(particles)\n    iw = weights[p]\n    nodeindices = neighboringnodes(iw)\n    Δvₚ = zero(eltype(particles.v))\n    ∇vₚ = zero(eltype(particles.∇v))\n    Δxₚ = zero(eltype(particles.x))\n    for ip in eachindex(nodeindices)\n        i = nodeindices[ip]\n        Δvₚ += iw.w[ip] * (grid.vⁿ[i] - grid.v[i])\n        ∇vₚ += grid.v[i] ⊗ iw.∇w[ip]\n        Δxₚ += iw.w[ip] * grid.v[i] * Δt\n    end\n    particles.v[p] += Δvₚ\n    particles.∇v[p] = ∇vₚ\n    particles.x[p] += Δxₚ\nend\n\n# Calculation on particle\nfor p in eachindex(particles)\n    Δϵₚ = symmetric(particles.∇v[p]) * Δt\n    particles.F[p]  = (I + particles.∇v[p]*Δt) * particles.F[p]\n    particles.V[p]  = particles.V⁰[p] * det(particles.F[p])\n    particles.σ[p] += λ*tr(Δϵₚ)*I + 2μ*Δϵₚ # Linear elastic material\nend\n\nwarning: Warning\nIn @G2P, Calculation on particles part must be placed after Grid-to-particle transfer part.\n\n\n\n\n\n","category":"macro"},{"location":"transfer/#Tesserae.@G2P2G","page":"Transfer between grid and particles","title":"Tesserae.@G2P2G","text":"@G2P2G grid=>i particles=>p weights=>ip [partition] begin\n    equations...\nend\n\nCombined grid-to-particle and particle-to-grid transfer macro.\n\nAllows both @G2P (interpolation from grid to particles) and @P2G (scattering from particles to grid) to be performed in a single loop over particles, avoiding repeated traversals.\n\nExamples\n\n@G2P2G grid=>i particles=>p weights=>ip begin\n    # G2P\n    ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n\n    # Particle update\n    F[p] = (I + ∇v[p]*Δt) * F[p]\n    σ[p] = cauchy_stress(F[p])\n\n    # P2G\n    f[i] = @∑ -V[p] * σ[p] * ∇w[ip]\nend\n\n\n\n\n\n","category":"macro"},{"location":"transfer/#Code-snippets","page":"Transfer between grid and particles","title":"Code snippets","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"info: Info\nThe following snippets are demonstrated in the tutorial Transfer schemes.","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"In this section, the following transfer schemes are presented:","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"PIC–FLIP mixed transfer[1]\nAffine PIC (APIC)[2]\nTaylor PIC (TPIC)[3]\neXtended PIC (XPIC)[4]","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"[1]: Stomakhin, A., Schroeder, C., Chai, L., Teran, J. and Selle, A., 2013. A material point method for snow simulation. ACM Transactions on Graphics (TOG), 32(4), pp.1-10.","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"[2]: Jiang, C., Schroeder, C., Selle, A., Teran, J. and Stomakhin, A., 2015. The affine particle-in-cell method. ACM Transactions on Graphics (TOG), 34(4), pp.1-10.","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"[3]: Nakamura, K., Matsumura, S. and Mizutani, T., 2023. Taylor particle-in-cell transfer and kernel correction for material point method. Computer Methods in Applied Mechanics and Engineering, 403, p.115720.","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"[4]: Hammerquist, C.C. and Nairn, J.A., 2017. A new method for material point method particle updates that reduces noise and enhances stability. Computer methods in applied mechanics and engineering, 318, pp.724-738.","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"We assume that the grid and particle properties have following variables:","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"using Tesserae #hide\nGridProp = @NamedTuple begin\n    x   :: Vec{2, Float64} # Position\n    m   :: Float64         # Mass\n    mv  :: Vec{2, Float64} # Momentum\n    v   :: Vec{2, Float64} # Velocity\n    vⁿ  :: Vec{2, Float64} # Velocity at t = tⁿ\n    # XPIC\n    vᵣ★ :: Vec{2, Float64}\n    v★  :: Vec{2, Float64}\nend\nParticleProp = @NamedTuple begin\n    x  :: Vec{2, Float64}                           # Position\n    m  :: Float64                                   # Mass\n    V⁰ :: Float64                                   # Initial volume\n    V  :: Float64                                   # Volume\n    v  :: Vec{2, Float64}                           # Velocity\n    ∇v :: SecondOrderTensor{2, Float64, 4}          # Velocity gradient\n    σ  :: SymmetricSecondOrderTensor{2, Float64, 3} # Cauchy stress\n    F  :: SecondOrderTensor{2, Float64, 4}          # Deformation gradient\n    # APIC\n    B  :: SecondOrderTensor{2, Float64, 4}\n    # XPIC\n    vᵣ★ :: Vec{2, Float64}\n    a★  :: Vec{2, Float64}\nend\nnothing #hide","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"grid = generate_grid(GridProp, CartesianMesh(1, (0,10), (0,10)))                          #hide\nparticles = generate_particles(ParticleProp, grid.x)                                      #hide\nweights = generate_interpolation_weights(BSpline(Quadratic()), grid.x, length(particles)) #hide\nfor p in eachindex(particles)                                                             #hide\n    update!(weights[p], particles.x[p], grid.x)                                           #hide\nend                                                                                       #hide\nα = 0.5                                                                                   #hide\nDₚ⁻¹ = inv(1/4 * spacing(grid.x)^2 * I)                                                   #hide\nm = 5                                                                                     #hide\nΔt = 1.0                                                                                  #hide\nnothing                                                                                   #hide","category":"page"},{"location":"transfer/#PIC–FLIP-mixed-transfer","page":"Transfer between grid and particles","title":"PIC–FLIP mixed transfer","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"beginaligned\nm^nbmv_i^n = sum_p w_ip^n m_p bmv_p^n \nbmv_p^n+1 = sum_i w_ip^n left( (1-alpha)bmv_i^n+1 + alpha (bmv_p^n + (bmv_i^n+1 - bmv_i^n) right)) \nendaligned","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"@P2G grid=>i particles=>p weights=>ip begin\n    mv[i] = @∑ w[ip] * m[p] * v[p]\nend\n@G2P grid=>i particles=>p weights=>ip begin\n    v[p] = @∑ w[ip] * ((1-α)*v[i] + α*(v[p] + (v[i]-vⁿ[i])))\nend","category":"page"},{"location":"transfer/#Affine-PIC-(APIC)","page":"Transfer between grid and particles","title":"Affine PIC (APIC)","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"beginaligned\nm^nbmv_i^n = sum_p w_ip^n m_p left(bmv_p^n + bmB_p^n (bmD_p^n)^-1 (bmx_i^n - bmx_p^n) right) \nbmv_p^n+1 = sum_i w_ip^n bmv_i^n+1 \nbmB_p^n+1 = sum_i w_ip^n bmv_i^n+1 otimes (bmx_i^n - bmx_p^n)\nendaligned","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"@P2G grid=>i particles=>p weights=>ip begin\n    mv[i] = @∑ w[ip] * m[p] * (v[p] + B[p] * Dₚ⁻¹ * (x[i] - x[p]))\nend\n@G2P grid=>i particles=>p weights=>ip begin\n    v[p] = @∑ w[ip] * v[i]\n    B[p] = @∑ w[ip] * v[i] ⊗ (x[i] - x[p])\nend","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"where Dₚ should be defined as Dₚ⁻¹ = inv(1/4 * h^2 * I) for BSpline(Quadratic()) (see the tutorial Transfer schemes).","category":"page"},{"location":"transfer/#Taylor-PIC-(TPIC)","page":"Transfer between grid and particles","title":"Taylor PIC (TPIC)","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"beginaligned\nm^nbmv_i^n = sum_p w_ip^n m_p left(bmv_p^n + nablabmv_p^n (bmx_i^n - bmx_p^n) right) \nbmv_p^n+1 = sum_i w_ip^n bmv_i^n+1 \nnablabmv_p^n+1 = sum_i bmv_i^n+1 otimes nabla w_ip^n \nendaligned","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"@P2G grid=>i particles=>p weights=>ip begin\n    mv[i] = @∑ w[ip] * m[p] * (v[p] + ∇v[p] * (x[i] - x[p]))\nend\n@G2P grid=>i particles=>p weights=>ip begin\n    v[p]  = @∑ w[ip] * v[i]\n    ∇v[p] = @∑ w[ip] * v[i] ⊗ (x[i] - x[p])\nend","category":"page"},{"location":"transfer/#eXtended-PIC-(XPIC)","page":"Transfer between grid and particles","title":"eXtended PIC (XPIC)","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"note: Note\nIn this section, we follow the notations in the original paper[4].","category":"page"},{"location":"transfer/#Overview-of-XPIC","page":"Transfer between grid and particles","title":"Overview of XPIC","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"We assume that bmmathsfS^+ matrix maps particle velocities to the grid and bmmathsfS matrix maps them back. In XPIC, a new effective acceleration for particles, mathbbA, is employed to update the particle velocity bmV and position bmX, respectively, as","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"beginaligned\nbmV^(k+1) = bmV^(k) + mathbbA^(k) Deltat \nbmX^(k+1) = bmX^(k) + bmmathsfS bmv^(k+) Deltat + left( frac12 mathbbA^(k) - bmmathsfSbma^(k) right) (Deltat)^2\nendaligned","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"where bmv^(k+) is the updated grid velocity:","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"bmv^(k+) = bmv^(k) + bma^(k) Deltat","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"The effective acceleration mathbbA is represented in XPIC as follows:","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"mathbbA^(k) Deltat = (1-m) bmmathsfSbma^(k)Deltat - bmV^(k) + mbmmathsfSbmv^(k+) - mbmmathsfSbmv^*","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"where","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"bmv^* = sum_r^m (-1)^r bmv_r^*","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"This new bmv_r^* term, which is unique to XPIC(m) with m1, can be evaluated by recursion:","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"bmv_r^* = fracm-r+1r bmmathsfS^+ bmmathsfS bmv_r-1^*","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"starting with bmv_1^*=bmv^(k).","category":"page"},{"location":"transfer/#Implementation-using-Tesserae","page":"Transfer between grid and particles","title":"Implementation using Tesserae","text":"","category":"section"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"Based on the above equations, we can derive the following:","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"beginaligned\nbmV^(k+1) = bmV^(k) + bmmathsfSleft(bmv^(k+)-bmv^(k)right) - bmA^* Deltat \nbmX^(k+1) = bmX^(k) + frac12 bmmathsfS left(bmv^(k+) + bmv^(k)right) Deltat - frac12 bmA^* (Deltat)^2\nendaligned","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"where","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"bmA^* Deltat = bmV^(k) + m bmmathsfS left( bmv^* - bmv^(k) right)","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"# Set the initial values for the recursion:\n@. grid.vᵣ★ = grid.vⁿ\n@. grid.v★ = zero(grid.v★)\n\n# The recursion process to calculate `v★`\nfor r in 2:m\n    @G2P grid=>i particles=>p weights=>ip begin\n        vᵣ★[p] = @∑ w[ip] * vᵣ★[i]\n    end\n    @P2G grid=>i particles=>p weights=>ip begin\n        vᵣ★[i] = @∑ (m-r+1)/r * w[ip] * m[p] * vᵣ★[p] / m[i]\n        v★[i] += (-1)^r * vᵣ★[i]\n    end\nend\n\n# Grid-to-particle transfer in XPIC\n@G2P grid=>i particles=>p weights=>ip begin\n    v[p] += @∑ w[ip] * (v[i] - vⁿ[i]) # same as FLIP\n    x[p] += @∑ w[ip] * (v[i] + vⁿ[i]) * Δt / 2\n    a★[p] = @∑ w[ip] * (v[p] + m*(v★[i] - vⁿ[i])) / Δt\n    v[p] -= a★[p] * Δt\n    x[p] -= a★[p] * Δt^2 / 2\nend","category":"page"},{"location":"transfer/","page":"Transfer between grid and particles","title":"Transfer between grid and particles","text":"where a★ represents bmA^*.","category":"page"},{"location":"tutorials/implicit_jacobian_free/#Jacobian-free-Newton–Krylov-method","page":"Jacobian-free","title":"Jacobian-free Newton–Krylov method","text":"","category":"section"},{"location":"tutorials/implicit_jacobian_free/","page":"Jacobian-free","title":"Jacobian-free","text":"<img src=\"https://github.com/user-attachments/assets/9d9dbb86-87d5-4818-bbbf-ae0983cd3f04\" width=\"800\"/>","category":"page"},{"location":"tutorials/implicit_jacobian_free/","page":"Jacobian-free","title":"Jacobian-free","text":"# Particles # Iterations Execution time (w/o output)\n26k 300 1 min","category":"page"},{"location":"tutorials/implicit_jacobian_free/","page":"Jacobian-free","title":"Jacobian-free","text":"using Tesserae\n\nusing Krylov: gmres\nusing LinearOperators: LinearOperator\n\nfunction main()\n\n    # Simulation parameters\n    h  = 0.05 # Grid spacing\n    T  = 3.0  # Time span\n    Δt = 0.01 # Time step\n\n    # Material constants\n    E  = 100e3                  # Young's modulus\n    ν  = 0.3                    # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 1000.0                 # Initial density\n\n    # Newmark-beta integration\n    β = 1/4\n    γ = 1/2\n\n    GridProp = @NamedTuple begin\n        X   :: Vec{3, Float64}\n        m   :: Float64\n        m⁻¹ :: Float64\n        v   :: Vec{3, Float64}\n        vⁿ  :: Vec{3, Float64}\n        mv  :: Vec{3, Float64}\n        a   :: Vec{3, Float64}\n        aⁿ  :: Vec{3, Float64}\n        ma  :: Vec{3, Float64}\n        u   :: Vec{3, Float64}\n        f   :: Vec{3, Float64}\n        δu  :: Vec{3, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x    :: Vec{3, Float64}\n        m    :: Float64\n        V⁰   :: Float64\n        v    :: Vec{3, Float64}\n        a    :: Vec{3, Float64}\n        ∇a   :: SecondOrderTensor{3, Float64, 9}\n        ∇u   :: SecondOrderTensor{3, Float64, 9}\n        F    :: SecondOrderTensor{3, Float64, 9}\n        ΔF⁻¹ :: SecondOrderTensor{3, Float64, 9}\n        τ    :: SecondOrderTensor{3, Float64, 9}\n        ℂ    :: FourthOrderTensor{3, Float64, 81}\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (0,1.5), (-0.6,0.6), (-0.6,0.6)))\n\n    # Particles\n    beam = extract(grid.X, (0,1.5), (-0.3,0.3), (-0.3,0.3))\n    particles = generate_particles(ParticleProp, beam; alg=GridSampling(spacing=1/6))\n    particles.V⁰ .= volume(beam) / length(particles)\n    filter!(particles) do pt\n        x, y, z = pt.x\n        (-0.3<y<-0.25 || 0.25<y<0.3) && (-0.3<z<-0.25 || 0.25<z<0.3)\n    end\n    @. particles.m = ρ⁰ * particles.V⁰\n    @. particles.F = one(particles.F)\n    @show length(particles)\n\n    # Interpolation\n    # Use the kernel correction to properly handle the boundary conditions\n    weights = generate_interpolation_weights(KernelCorrection(BSpline(Quadratic())), grid.X, length(particles))\n\n    # Neo-Hookean model\n    function kirchhoff_stress(F)\n        J = det(F)\n        b = symmetric(F * F')\n        μ*(b-I) + λ*log(J)*I\n    end\n\n    # Outputs\n    outdir = mkpath(joinpath(\"output\", \"implicit_jacobian_free\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 60\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        update!(weights, particles, grid.X)\n\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]  = @∑ w[ip] * m[p]\n            mv[i] = @∑ w[ip] * m[p] * v[p]\n            ma[i] = @∑ w[ip] * m[p] * a[p]\n        end\n\n        # Compute the grid velocity and acceleration at t = tⁿ\n        @. grid.m⁻¹ = inv(grid.m) * !iszero(grid.m)\n        @. grid.vⁿ = grid.mv * grid.m⁻¹\n        @. grid.aⁿ = grid.ma * grid.m⁻¹\n\n        # Create dofmask\n        dofmask = trues(3, size(grid)...)\n        for i in eachindex(grid)\n            iszero(grid.m[i]) && (dofmask[:,i] .= false)\n        end\n\n        # Update boundary conditions\n        @. grid.u = zero(grid.u)\n        for i in eachindex(grid)[1,:,:]\n            dofmask[:,i] .= false\n        end\n        for i in eachindex(grid)[end,:,:]\n            dofmask[:,i] .= false\n            grid.u[i] = (rotmat(2π*Δt, Vec(1,0,0)) - I) * grid.X[i]\n        end\n        dofmap = DofMap(dofmask)\n\n        # Solve the nonlinear equation\n        state = (; grid, particles, weights, kirchhoff_stress, β, γ, dofmap, Δt)\n        U = copy(dofmap(grid.u)) # Convert grid data to plain vector data\n        compute_residual(U) = residual(U, state)\n        compute_jacobian(U) = jacobian(U, state)\n        Tesserae.newton!(U, compute_residual, compute_jacobian; linsolve = (x,A,b)->copy!(x,gmres(A,b)[1]))\n\n        # Grid dispacement, velocity and acceleration have been updated during Newton's iterations\n        @G2P grid=>i particles=>p weights=>ip begin\n            v[p] += @∑ w[ip] * ((1-γ)*a[p] + γ*a[i]) * Δt\n            a[p]  = @∑ w[ip] * a[i]\n            x[p]  = @∑ w[ip] * (X[i] + u[i])\n            ∇u[p] = @∑ u[i] ⊗ ∇w[ip]\n            F[p]  = (I + ∇u[p]) * F[p]\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtk(string(pvdfile, step), particles.x) do vtk\n                    vtk[\"Velocity (m/s)\"] = particles.v\n                    vtk[\"von Mises stress (kPa)\"] = @. 1e-3 * vonmises(particles.τ / det(particles.F))\n                    pvd[t] = vtk\n                end\n            end\n        end\n    end\nend\n\nfunction residual(U::AbstractVector, state)\n    (; grid, particles, weights, kirchhoff_stress, β, γ, dofmap, Δt) = state\n\n    dofmap(grid.u) .= U\n    @. grid.a = (1/(β*Δt^2))*grid.u - (1/(β*Δt))*grid.vⁿ - (1/2β-1)*grid.aⁿ\n    @. grid.v = grid.vⁿ + ((1-γ)*grid.aⁿ + γ*grid.a) * Δt\n\n    geometric(τ) = @einsum (i,j,k,l) -> τ[i,l] * one(τ)[j,k]\n    @G2P2G grid=>i particles=>p weights=>ip begin\n        # In addition to updating the stress tensor, the stiffness tensor,\n        # which is utilized in the Jacobian-vector product, is also updated.\n        ∇u[p] = @∑ u[i] ⊗ ∇w[ip]\n        ΔF⁻¹[p] = inv(I + ∇u[p])\n        F = (I + ∇u[p]) * F[p]\n        ∂τ∂F, τ = gradient(kirchhoff_stress, F, :all)\n        τ[p] = τ\n        ℂ[p] = ∂τ∂F ⊡ F' - geometric(τ)\n        f[i] = @∑ V⁰[p] * τ[p] * (∇w[ip] ⊡ ΔF⁻¹[p])\n    end\n\n    @. β*Δt^2 * ($dofmap(grid.a) + $dofmap(grid.f) * $dofmap(grid.m⁻¹))\nend\n\nfunction jacobian(U::AbstractVector, state)\n    (; grid, particles, weights, β, dofmap, Δt) = state\n\n    # Create a linear map to represent Jacobian-vector product J*δU.\n    # `U` is acutally not used because the stiffness tensor is already calculated\n    # when computing the residual vector.\n    fillzero!(grid.δu)\n    function mul!(JδU, δU)\n        dofmap(grid.δu) .= δU\n\n        @G2P2G grid=>i particles=>p weights=>ip begin\n            ∇u[p] = @∑ δu[i] ⊗ (∇w[ip] ⊡ ΔF⁻¹[p])\n            τ[p] = ℂ[p] ⊡₂ ∇u[p]\n            f[i] = @∑ V⁰[p] * τ[p] * (∇w[ip] ⊡ ΔF⁻¹[p])\n        end\n\n        @. JδU = δU + β*Δt^2 * $dofmap(grid.f) * $dofmap(grid.m⁻¹)\n    end\n    LinearOperator(Float64, ndofs(dofmap), ndofs(dofmap), false, false, mul!)\nend","category":"page"},{"location":"tutorials/implicit_jacobian_free/","page":"Jacobian-free","title":"Jacobian-free","text":"","category":"page"},{"location":"tutorials/implicit_jacobian_free/","page":"Jacobian-free","title":"Jacobian-free","text":"This page was generated using Literate.jl.","category":"page"},{"location":"export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"export/","page":"Export","title":"Export","text":"In Tesserae, exporting VTK files for visualization is supported. These functionalities are built on the WriteVTK.jl package.","category":"page"},{"location":"export/#VTK-file","page":"Export","title":"VTK file","text":"","category":"section"},{"location":"export/","page":"Export","title":"Export","text":"To export the mesh or particles, use openvtk and closevtk functions. First, we prepare following grid and particles:","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"using Tesserae #hide\n\nGridProp = @NamedTuple begin\n    x  :: Vec{2, Float64}\n    m  :: Float64\n    mv :: Vec{2, Float64}\n    f  :: Vec{2, Float64}\nend\nParticleProp = @NamedTuple begin\n    x :: Vec{2, Float64}\n    m :: Float64\n    v :: Vec{2, Float64}\nend\n\ngrid = generate_grid(GridProp, CartesianMesh(1, (0, 3), (0, 4)))\nparticles = generate_particles(ParticleProp, grid.x)\nnothing #hide","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"The grid properties can be exported as","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"vtk_grid = openvtk(\"grid\", grid.x)\nvtk_grid[\"Momentum\"] = grid.mv\nvtk_grid[\"Force\"] = grid.f\nclosevtk(vtk_grid)","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"This can also be written using a do block, which automatically closes the file:","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"openvtk(\"grid\", grid.x) do vtk\n    vtk[\"Momentum\"] = grid.mv\n    vtk[\"Force\"] = grid.f\nend","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"For particles, the same instruction is available:","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"# without do block\nvtk_particles = openvtk(\"particles\", particles.x)\nvtk_particles[\"Velocity\"] = particles.v\nclosevtk(vtk_particles)\n\n# with do block\nopenvtk(\"particles\", particles.x) do vtk\n    vtk[\"Velocity\"] = particles.v\nend","category":"page"},{"location":"export/#Multiblock-data-set","page":"Export","title":"Multiblock data set","text":"","category":"section"},{"location":"export/","page":"Export","title":"Export","text":"Sometimes, we want to export both the grid and particles into a single dataset. This can be done using a vtm file with the openvtm and closevtm functions.","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"openvtm(\"grid_and_particles\") do vtm\n    openvtk(vtm, grid.x) do vtk\n        vtk[\"Momentum\"] = grid.mv\n        vtk[\"Force\"] = grid.f\n    end\n    openvtk(vtm, particles.x) do vtk\n        vtk[\"Velocity\"] = particles.x\n    end\nend","category":"page"},{"location":"export/#ParaView-collection-file","page":"Export","title":"ParaView collection file","text":"","category":"section"},{"location":"export/","page":"Export","title":"Export","text":"A ParaView collection file (pvd) represents a time series of VTK files.","category":"page"},{"location":"export/","page":"Export","title":"Export","text":"filename = \"Simulation\"\nclosepvd(openpvd(filename)) # Just create a file by `closepvd`\n\nfor (step, t) in enumerate(range(0, 10, step=0.5))\n\n    # Simulation...\n\n    # Reopening and closing the file at each time step allows us\n    # to visualize intermediate results # without having to wait\n    # for the simulation to finish.\n    openpvd(filename; append=true) do pvd\n        openvtm(string(filename, step)) do vtm\n            openvtk(vtm, grid.x) do vtk\n                vtk[\"Momentum\"] = grid.mv\n                vtk[\"Force\"] = grid.f\n            end\n            openvtk(vtm, particles.x) do vtk\n                vtk[\"Velocity\"] = particles.v\n            end\n            pvd[t] = vtm # save to pvd!\n        end\n    end\nend","category":"page"},{"location":"tutorials/dam_break/#Stabilized-mixed-MPM-for-incompressible-fluid-flow","page":"Incompressible fluid flow","title":"Stabilized mixed MPM for incompressible fluid flow","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"<img src=\"https://github.com/user-attachments/assets/dfc9fb4e-6223-460e-ac34-310363cd6a78\" width=\"600\"/>","category":"page"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"# Particles # Iterations Execution time (w/o output)\n28k 3.5k 12 min","category":"page"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"This example employs stabilized mixed MPM with the variational multiscale method[1].","category":"page"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"[1]: Chandra, B., Hashimoto, R., Matsumi, S., Kamrin, K. and Soga, K., 2024. Stabilized mixed material point method for incompressible fluid flow analysis. Computer Methods in Applied Mechanics and Engineering, 419, p.116644.","category":"page"},{"location":"tutorials/dam_break/#Main-function","page":"Incompressible fluid flow","title":"Main function","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"using Tesserae\nusing LinearAlgebra\n\nusing Krylov: gmres\nusing LinearOperators: LinearOperator\nimport AlgebraicMultigrid as AMG\n\nstruct FLIP α::Float64 end\nstruct TPIC end\n\nfunction main(transfer = FLIP(1.0))\n\n    # Simulation parameters\n    h  = 0.02   # Grid spacing\n    T  = 7.0    # Time span\n    g  = 9.81   # Gravity acceleration\n    Δt = 2.0e-3 # Time step\n\n    # Material constants\n    ρ = 1.0e3   # Initial density\n    μ = 1.01e-3 # Dynamic viscosity (Pa⋅s)\n\n    # Newmark-beta method\n    β = 0.5\n    γ = 1.0\n\n    # Utils\n    cellnodes(cell) = cell:(cell+oneunit(cell))\n    cellcenter(cell, mesh) = sum(mesh[cellnodes(cell)]) / 4\n\n    # Properties for grid and particles\n    GridProp = @NamedTuple begin\n        X   :: Vec{2, Float64}\n        x   :: Vec{2, Float64}\n        m   :: Float64\n        v   :: Vec{2, Float64}\n        vⁿ  :: Vec{2, Float64}\n        mv  :: Vec{2, Float64}\n        a   :: Vec{2, Float64}\n        aⁿ  :: Vec{2, Float64}\n        ma  :: Vec{2, Float64}\n        u   :: Vec{2, Float64}\n        p   :: Float64\n        # δ-correction\n        V   :: Float64\n        Ṽ   :: Float64\n        E   :: Float64\n        # Residuals\n        u_p   :: Vec{3, Float64}\n        R_mom :: Vec{2, Float64}\n        R_mas :: Float64\n    end\n    ParticleProp = @NamedTuple begin\n        x   :: Vec{2, Float64}\n        m   :: Float64\n        V   :: Float64\n        v   :: Vec{2, Float64}\n        ∇v  :: SecondOrderTensor{2, Float64, 4}\n        a   :: Vec{2, Float64}\n        ∇a  :: SecondOrderTensor{2, Float64, 4}\n        p   :: Float64\n        ∇p  :: Vec{2, Float64}\n        s   :: SymmetricSecondOrderTensor{2, Float64, 3}\n        b   :: Vec{2, Float64}\n        # δ-correction\n        ∇E² :: Vec{2, Float64}\n        # Stabilization\n        τ₁  :: Float64\n        τ₂  :: Float64\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (0,3.22), (0,2.5)))\n    for cell in CartesianIndices(size(grid).-1)\n        for i in cellnodes(cell)\n            grid.V[i] += (h/2)^2\n        end\n    end\n\n    # Particles\n    particles = generate_particles(ParticleProp, grid.X; alg=PoissonDiskSampling(spacing=1/4))\n    particles.V .= volume(grid.X) / length(particles)\n    filter!(pt -> pt.x[1]<1.2 && pt.x[2]<0.6, particles)\n    @. particles.m = ρ * particles.V\n    @. particles.b = Vec(0,-g)\n    @show length(particles)\n\n    # Interpolation weights\n    interp = KernelCorrection(BSpline(Quadratic()))\n    weights = generate_interpolation_weights(interp, grid.X, length(particles); name=Val(:S))\n    weights_cell = generate_interpolation_weights(interp, grid.X, size(grid) .- 1; name=Val(:S))\n\n    # Sparse matrix\n    A = create_sparse_matrix(interp, grid.X; ndofs=3)\n\n    # Output\n    outdir = mkpath(joinpath(\"output\", \"dam_break\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 30\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        # Update interpolation values based on the nodes of active cells\n        # where the particles are located\n        activenodes = falses(size(grid))\n        for p in eachindex(particles)\n            cell = whichcell(particles.x[p], grid.X)\n            activenodes[cellnodes(cell)] .= true\n        end\n        update!(weights, particles, grid.X, activenodes)\n        for cell in CartesianIndices(size(grid) .- 1)\n            xc = cellcenter(cell, grid.X)\n            if all(i->activenodes[i], cellnodes(cell))\n                update!(weights_cell[cell], xc, grid.X, activenodes)\n            end\n        end\n\n        if transfer isa FLIP\n            @P2G grid=>i particles=>p weights=>ip begin\n                m[i]  = @∑ S[ip] * m[p]\n                mv[i] = @∑ S[ip] * m[p] * v[p]\n                ma[i] = @∑ S[ip] * m[p] * a[p]\n            end\n        elseif transfer isa TPIC\n            @P2G grid=>i particles=>p weights=>ip begin\n                m[i]  = @∑ S[ip] * m[p]\n                mv[i] = @∑ S[ip] * m[p] * (v[p] + ∇v[p] * (X[i] - x[p]))\n                ma[i] = @∑ S[ip] * m[p] * (a[p] + ∇a[p] * (X[i] - x[p]))\n            end\n        end\n\n        m_tol = sqrt(eps(eltype(grid.m))) * maximum(grid.m)\n        m_mask = @. !(grid.m ≤ m_tol)\n        @. grid.vⁿ = grid.mv / grid.m * m_mask\n        @. grid.aⁿ = grid.ma / grid.m * m_mask\n\n        # Update a dof map\n        dofmask_u = falses(3, size(grid)...)\n        dofmask_p = falses(3, size(grid)...)\n        for i in 1:2\n            dofmask_u[i,:,:] = m_mask\n        end\n        dofmask_p[3,:,:] = m_mask\n        for i in @view eachindex(grid)[[begin,end],:] # Walls\n            grid.vⁿ[i] = grid.vⁿ[i] .* (false,true)\n            grid.aⁿ[i] = grid.aⁿ[i] .* (false,true)\n            dofmask_u[1,i] = false\n        end\n        for i in @view eachindex(grid)[:,begin] # Floor\n            grid.vⁿ[i] = grid.vⁿ[i] .* (true,false)\n            grid.aⁿ[i] = grid.aⁿ[i] .* (true,false)\n            dofmask_u[2,i] = false\n        end\n        dofmap_u = DofMap(dofmask_u)\n        dofmap_p = DofMap(dofmask_p)\n        dofmap = DofMap(dofmask_u .| dofmask_p)\n\n        # Solve grid position, dispacement, velocity, acceleration and pressure by VMS method\n        state = (; grid, particles, weights, weights_cell, ρ, μ, β, γ, A, dofmap, dofmap_u, dofmap_p, Δt)\n        variational_multiscale_method(state)\n\n        if transfer isa FLIP\n            α = transfer.α\n            @G2P grid=>i particles=>p weights=>ip begin\n                v[p] = @∑ ((1-α)*v[i] + α*(v[p] + ((1-γ)*a[p] + γ*a[i])*Δt)) * S[ip]\n                a[p] = @∑ a[i] * S[ip]\n                x[p] = @∑ x[i] * S[ip]\n            end\n        elseif transfer isa TPIC\n            @G2P grid=>i particles=>p weights=>ip begin\n                v[p] = @∑ v[i] * S[ip]\n                a[p] = @∑ a[i] * S[ip]\n                x[p] = @∑ x[i] * S[ip]\n                ∇v[p] = @∑ v[i] ⊗ ∇S[ip]\n                ∇a[p] = @∑ a[i] ⊗ ∇S[ip]\n            end\n        end\n\n        # Particle shifting based on the δ-correction\n        particle_shifting(state)\n\n        # Remove particles that accidentally move outside of the mesh\n        outside = findall(x->!isinside(x, grid.X), particles.x)\n        deleteat!(particles, outside)\n\n        t += Δt\n        step += 1\n\n        # Write results\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtm(string(pvdfile, step)) do vtm\n                    vorticity(∇v) = ∇v[2,1] - ∇v[1,2]\n                    openvtk(vtm, particles.x) do vtk\n                        vtk[\"Pressure (Pa)\"] = particles.p\n                        vtk[\"Velocity (m/s)\"] = particles.v\n                        vtk[\"Vorticity (1/s)\"] = vorticity.(particles.∇v)\n                    end\n                    openvtk(vtm, grid.X) do vtk\n                    end\n                    pvd[t] = vtm\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/dam_break/#Variational-multiscale-method","page":"Incompressible fluid flow","title":"Variational multiscale method","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"function variational_multiscale_method(state)\n\n    (; grid, dofmap, dofmap_u, dofmap_p, β, γ, Δt) = state\n    @. grid.u_p = zero(grid.u_p)\n\n    # Compute VMS stabilization coefficients using current grid velocity,\n    # which is used for Jacobian matrix\n    grid.v .= grid.vⁿ\n    compute_VMS_stabilization_coefficients(state)\n\n    # Solve nonlinear system using GMRES with incomplete LU preconditioner\n    K = jacobian(state)\n\n    # Extract the activated degrees of freedom\n    A = extract(K, dofmap, dofmap)\n    Aᵤᵤ = extract(K, dofmap_u, dofmap_u) # dispacement-dispacement\n    Aᵤₚ = extract(K, dofmap_u, dofmap_p) # dispacement-pressure\n    Aₚᵤ = extract(K, dofmap_p, dofmap_u) # pressure-dispacement\n    Aₚₚ = extract(K, dofmap_p, dofmap_p) # pressure-pressure\n\n    # Reindex DOFs relative to the extracted `A` (not the full `K`).\n    dofs_u = indexin(dofs(dofmap_u), dofs(dofmap))\n    dofs_p = indexin(dofs(dofmap_p), dofs(dofmap))\n\n    # Build block preconditioner (approximate Schur complement form)\n    # - Pᵤ: dispacement block preconditioner from Aᵤᵤ\n    # - Pₚ: pressure block preconditioner from approximate Schur complement\n    α = -γ/(β*Δt)\n    nₚₚ = size(Aₚₚ, 1)\n    Iϵ = sqrt(eps(Float64)) * tr(Aₚₚ) / nₚₚ * Diagonal(ones(nₚₚ))\n    Pᵤ = AMG.aspreconditioner(AMG.smoothed_aggregation(Aᵤᵤ))\n    Pₚ = AMG.aspreconditioner(AMG.smoothed_aggregation(Aₚₚ - (α*Aᵤₚ') * inv(Diagonal(Aᵤᵤ)) * Aᵤₚ + Iϵ))\n\n    # Define operator of block preconditioner\n    P⁻¹ = LinearOperator(Float64, size(A)..., false, false, (y, r) -> begin\n        yᵤ = view(y, dofs_u); yₚ = view(y, dofs_p)\n        rᵤ = view(r, dofs_u); rₚ = view(r, dofs_p)\n        yᵤ .= Pᵤ \\ rᵤ\n        yₚ .= Pₚ \\ (rₚ - (Aₚᵤ * Array(yᵤ)))\n    end)\n\n    U = zeros(ndofs(dofmap)) # Initialize nodal dispacement and pressure with zero\n    linsolve(x, A, b) = copy!(x, gmres(A, b; N=P⁻¹)[1])\n    Tesserae.newton!(U, U->residual(U,state), U->A; linsolve, maxiter=20, backtracking=true)\n\n    # Update the positions of grid nodes\n    @. grid.x = grid.X + grid.u\nend","category":"page"},{"location":"tutorials/dam_break/#VMS-stabilization-coefficients","page":"Incompressible fluid flow","title":"VMS stabilization coefficients","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"function compute_VMS_stabilization_coefficients(state)\n    (; grid, particles, weights_cell, ρ, μ, Δt) = state\n\n    c₁ = 4.0\n    c₂ = 2.0\n    τdyn = 1.0\n    h = sqrt(4*spacing(grid.X)^2/π)\n\n    # In the following computation, `@G2P` is unavailable\n    # due to the use of `weights_cell`\n    for p in eachindex(particles)\n        v̄ₚ = zero(eltype(particles.v))\n        iw = weights_cell[whichcell(particles.x[p], grid.X)]\n        gridindices = neighboringnodes(iw, grid)\n        for ip in eachindex(gridindices)\n            i = gridindices[ip]\n            v̄ₚ += iw.S[ip] * grid.v[i]\n        end\n        τ₁ = inv(ρ*τdyn/Δt + c₂*ρ*norm(v̄ₚ)/h + c₁*μ/h^2)\n        τ₂ = h^2 / (c₁*τ₁)\n        particles.τ₁[p] = τ₁\n        particles.τ₂[p] = τ₂\n    end\nend","category":"page"},{"location":"tutorials/dam_break/#δ-correction","page":"Incompressible fluid flow","title":"δ-correction","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"function particle_shifting(state)\n    (; grid, particles, weights) = state\n\n    @P2G grid=>i particles=>p weights=>ip begin\n        Ṽ[i] = @∑ V[p] * S[ip]\n        E[i] = max(0, -V[i] + Ṽ[i])\n    end\n\n    E² = sum(E->E^2, grid.E)\n    @G2P grid=>i particles=>p weights=>ip begin\n        ∇E²[p] = @∑ 2V[p] * E[i] * ∇S[ip]\n    end\n\n    b₀ = E² / sum(∇E²->∇E²⋅∇E², particles.∇E²)\n\n    for p in eachindex(particles)\n        xₚ = particles.x[p] - b₀ * particles.∇E²[p]\n        if isinside(xₚ, grid.X)\n            particles.x[p] = xₚ\n        end\n    end\nend","category":"page"},{"location":"tutorials/dam_break/#Residual-vector","page":"Incompressible fluid flow","title":"Residual vector","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"function residual(U, state)\n    (; grid, particles, weights, μ, β, γ, dofmap, Δt) = state\n\n    # Map `U` to grid dispacement and pressure\n    dofmap(grid.u_p) .= U\n    grid.u .= map(x->@Tensor(x[1:2]), grid.u_p)\n    grid.p .= map(x->x[3], grid.u_p)\n\n    # Recompute nodal velocity and acceleration based on the Newmark-beta method\n    @. grid.v = γ/(β*Δt)*grid.u - (γ/β-1)*grid.vⁿ - Δt/2*(γ/β-2)*grid.aⁿ\n    @. grid.a = 1/(β*Δt^2)*grid.u - 1/(β*Δt)*grid.vⁿ - (1/2β-1)*grid.aⁿ\n\n    # Compute VMS stabilization coefficients based on the current nodal velocity\n    compute_VMS_stabilization_coefficients(state)\n\n    # Compute residual values\n    @G2P2G grid=>i particles=>p weights=>ip begin\n        a[p]  = @∑ a[i] * S[ip]\n        p[p]  = @∑ p[i] * S[ip]\n        ∇v[p] = @∑ v[i] ⊗ ∇S[ip]\n        ∇p[p] = @∑ p[i] * ∇S[ip]\n        s[p]  = 2μ * symmetric(∇v[p])\n        R_mom[i]  = @∑ V[p]*s[p]*∇S[ip] - m[p]*b[p]*S[ip] - V[p]*p[p]*∇S[ip] + τ₂[p]*V[p]*tr(∇v[p])*∇S[ip]\n        R_mas[i]  = @∑ V[p]*tr(∇v[p])*S[ip] + τ₁[p]*m[p]*(a[p]-b[p])⋅∇S[ip] + τ₁[p]*V[p]*∇p[p]⋅∇S[ip]\n        R_mom[i] += m[i]*a[i]\n    end\n\n    # Map grid values to vector `R`\n    Array(dofmap(map(vcat, grid.R_mom, grid.R_mas)))\nend","category":"page"},{"location":"tutorials/dam_break/#Jacobian-matrix","page":"Incompressible fluid flow","title":"Jacobian matrix","text":"","category":"section"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"function jacobian(state)\n    (; grid, particles, weights, ρ, μ, β, γ, A, dofmap, Δt) = state\n\n    # Construct the Jacobian matrix\n    cₚ = 2μ * one(SymmetricFourthOrderTensor{2})\n    I(i,j) = ifelse(i===j, one(Mat{2,2}), zero(Mat{2,2}))\n    @P2G_Matrix grid=>(i,j) particles=>p weights=>(ip,jp) begin\n        A[i,j] = @∑ begin\n            Kᵤᵤ = (γ/(β*Δt) * ∇S[ip] ⊡ cₚ ⊡ ∇S[jp]) * V[p] + 1/(β*Δt^2) * I(i,j) * m[p] * S[jp]\n            Kᵤₚ = -∇S[ip] * S[jp] * V[p]\n            Kₚᵤ = (γ/(β*Δt)) * S[ip] * ∇S[jp] * V[p]\n            K̂ᵤᵤ = γ/(β*Δt) * τ₂[p] * ∇S[ip] ⊗ ∇S[jp] * V[p]\n            K̂ₚᵤ = 1/(β*Δt^2) * τ₁[p] * ρ * ∇S[ip] * S[jp] * V[p]\n            K̂ₚₚ = τ₁[p] * ∇S[ip] ⋅ ∇S[jp] * V[p]\n            [Kᵤᵤ+K̂ᵤᵤ    Kᵤₚ\n             (Kₚᵤ+K̂ₚᵤ)' K̂ₚₚ]\n        end\n    end\n\n    A\nend","category":"page"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"","category":"page"},{"location":"tutorials/dam_break/","page":"Incompressible fluid flow","title":"Incompressible fluid flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/collapse/#Elasto-plastic-large-deformation","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"","category":"section"},{"location":"tutorials/collapse/","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"<img src=\"https://github.com/user-attachments/assets/16a48085-6977-4c6f-b9fa-a9634e73eeef\" width=\"800\"/>","category":"page"},{"location":"tutorials/collapse/","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"# Particles # Iterations Execution time (w/o output)\n19k 8k 20 sec","category":"page"},{"location":"tutorials/collapse/#Drucker–Prager-model","page":"Elasto-plastic large deformation","title":"Drucker–Prager model","text":"","category":"section"},{"location":"tutorials/collapse/","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"using Tesserae\n\n@kwdef struct DruckerPrager\n    λ  :: Float64            # Lame's first parameter\n    G  :: Float64            # Shear modulus\n    ϕ  :: Float64            # Internal friction angle\n    ψ  :: Float64 = ϕ        # Dilatancy angle\n    c  :: Float64 = 0.0      # Cohesion\n    pₜ :: Float64 = c/tan(ϕ) # Mean stress for tension limit\n    # Assume plane strain condition\n    A  :: Float64 = 3√2c      / sqrt(9+12tan(ϕ)^2)\n    B  :: Float64 = 3√2tan(ϕ) / sqrt(9+12tan(ϕ)^2)\n    b  :: Float64 = 3√2tan(ψ) / sqrt(9+12tan(ψ)^2)\nend\n\nfunction cauchy_stress(model::DruckerPrager, σⁿ::SymmetricSecondOrderTensor{3}, ∇u::SecondOrderTensor{3})\n    δ = one(SymmetricSecondOrderTensor{3})\n    I = one(SymmetricFourthOrderTensor{3})\n\n    (; λ, G, A, B, b, pₜ) = model\n\n    f(σ) = norm(dev(σ)) - (A - B*tr(σ)/3) # Yield function\n    g(σ) = norm(dev(σ)) + b*tr(σ)/3       # Plastic potential function\n\n    # Elastic predictor\n    cᵉ = λ*δ⊗δ + 2G*I\n    σᵗʳ = σⁿ + cᵉ ⊡₂ symmetric(∇u) + 2*symmetric(σⁿ * skew(∇u)) # Consider Jaumann stress-rate\n    dfdσ, fᵗʳ = gradient(f, σᵗʳ, :all)\n    fᵗʳ ≤ 0 && tr(σᵗʳ)/3 ≤ pₜ && return σᵗʳ\n\n    # Plastic corrector\n    dgdσ = gradient(g, σᵗʳ)\n    Δλ = fᵗʳ / (dfdσ ⊡₂ cᵉ ⊡₂ dgdσ)\n    Δεᵖ = Δλ * dgdσ\n    σ = σᵗʳ - cᵉ ⊡₂ Δεᵖ\n\n    # Simple tension cutoff\n    if !(tr(σ)/3 ≤ pₜ) # σᵗʳ is not in zone1\n        #\n        # \\<- yield surface\n        #  \\         /\n        #   \\ zone1 /\n        #    \\     /   zone2\n        #     \\   /\n        #      \\ /______________\n        #       |\n        #       |      zone3\n        #       |\n        # ------------------------> p\n        #       pₜ\n        #\n        s = dev(σᵗʳ)\n        σ = pₜ*δ + s\n        if f(σ) > 0 # σ is in zone2\n            # Map to corner\n            p = tr(σ) / 3\n            σ = pₜ*δ + (A-B*p)*normalize(s)\n        end\n    end\n\n    σ\nend","category":"page"},{"location":"tutorials/collapse/#Sand-column-collapse","page":"Elasto-plastic large deformation","title":"Sand column collapse","text":"","category":"section"},{"location":"tutorials/collapse/","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"function main()\n\n    # Simulation parameters\n    h   = 0.01 # Grid spacing\n    T   = 1.5  # Time span\n    g   = 9.81 # Gravity acceleration\n    CFL = 1.0  # Courant number\n\n    # Material constants\n    E  = 1e6                    # Young's modulus\n    ν  = 0.3                    # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    G  = E / 2(1 + ν)           # Shear modulus\n    ϕ  = deg2rad(32)            # Internal friction angle\n    ψ  = deg2rad(0)             # Dilatancy angle\n    ρ⁰ = 1.5e3                  # Initial density\n\n    # Geometry\n    H = 0.8 # Height of sand column\n    W = 0.6 # Width of sand column\n\n    GridProp = @NamedTuple begin\n        x  :: Vec{2, Float64}\n        m  :: Float64\n        m⁻¹ :: Float64\n        v  :: Vec{2, Float64}\n        vⁿ :: Vec{2, Float64}\n        mv :: Vec{2, Float64}\n        f  :: Vec{2, Float64}\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{2, Float64}\n        m  :: Float64\n        V  :: Float64\n        v  :: Vec{2, Float64}\n        ∇v :: SecondOrderTensor{2, Float64, 4}\n        F  :: SecondOrderTensor{2, Float64, 4}\n        σ  :: SymmetricSecondOrderTensor{3, Float64, 6}\n    end\n\n    # Background grid\n    grid = generate_grid(GridProp, CartesianMesh(h, (-3,3), (0,1)))\n\n    # Particles\n    particles = generate_particles(ParticleProp, grid.x)\n    particles.V .= volume(grid.x) / length(particles)\n    filter!(particles) do pt\n        x, y = pt.x\n        -W/2 < x < W/2 && y < H\n    end\n    for p in eachindex(particles)\n        y = particles.x[p][2]\n        σ_y = -ρ⁰ * g * (H-y)\n        σ_x = σ_y * ν / (1-ν)\n        particles.σ[p] = diagm(Vec(σ_x, σ_y, σ_x))\n    end\n    @. particles.m = ρ⁰ * particles.V\n    @. particles.F = one(particles.F)\n    @show length(particles)\n\n    # Interpolation weights\n    weights = generate_interpolation_weights(KernelCorrection(BSpline(Quadratic())), grid.x, length(particles))\n\n    # Material model\n    model = DruckerPrager(; λ, G, ϕ, ψ)\n\n    # Outputs\n    outdir = mkpath(joinpath(\"output\", \"collapse\"))\n    pvdfile = joinpath(outdir, \"paraview\")\n    closepvd(openpvd(pvdfile)) # Create file\n\n    t = 0.0\n    step = 0\n    fps = 60\n    savepoints = collect(LinRange(t, T, round(Int, T*fps)+1))\n\n    Tesserae.@showprogress while t < T\n\n        # Calculate time step based on the wave speed\n        vmax = maximum(@. sqrt((λ+2G) / (particles.m/particles.V)) + norm(particles.v))\n        Δt = CFL * h / vmax\n\n        # Update interpolation weights\n        update!(weights, particles, grid.x)\n\n        # Particle-to-grid transfer\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]  = @∑ w[ip] * m[p]\n            mv[i] = @∑ w[ip] * m[p] * v[p]\n            f[i]  = @∑ -V[p] * resize(σ[p],(2,2)) * ∇w[ip] + w[ip] * m[p] * Vec(0,-g)\n            m⁻¹[i] = inv(m[i]) * !iszero(m[i])\n            vⁿ[i]  = mv[i] * m⁻¹[i]\n            v[i]   = vⁿ[i] + (f[i] * m⁻¹[i]) * Δt\n        end\n\n        # Boundary conditions\n        for i in eachindex(grid)[:,begin]\n            μ = 0.4 # Friction coefficient on the floor\n            n = Vec(0,-1)\n            vᵢ = grid.v[i]\n            if !iszero(vᵢ)\n                v̄ₙ = vᵢ ⋅ n\n                vₜ = vᵢ - v̄ₙ*n\n                v̄ₜ = norm(vₜ)\n                grid.v[i] = vᵢ - (v̄ₙ*n + min(μ*v̄ₙ, v̄ₜ) * vₜ/v̄ₜ)\n            end\n        end\n\n        # Grid-to-particle transfer\n        @G2P grid=>i particles=>p weights=>ip begin\n            v[p] += @∑ w[ip] * (v[i] - vⁿ[i])\n            ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n            x[p] += @∑ w[ip] * v[i] * Δt\n            # Update Cauchy stress using Jaumann stress rate\n            ∇uₚ = resize(∇v[p], (3,3)) * Δt\n            σ[p] = cauchy_stress(model, σ[p], ∇uₚ)\n            # Update deformation gradient and volume\n            ΔFₚ = I + ∇v[p] * Δt\n            F[p] = ΔFₚ * F[p]\n            V[p] = det(ΔFₚ) * V[p]\n        end\n\n        t += Δt\n        step += 1\n\n        if t > first(savepoints)\n            popfirst!(savepoints)\n            openpvd(pvdfile; append=true) do pvd\n                openvtm(string(pvdfile, step)) do vtm\n                    openvtk(vtm, particles.x) do vtk\n                        vtk[\"Velocity (m/s)\"] = particles.v\n                        vtk[\"ID\"] = eachindex(particles.v)\n                    end\n                    openvtk(vtm, grid.x) do vtk\n                        vtk[\"Velocity (m/s)\"] = grid.v\n                    end\n                    pvd[t] = vtm\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/collapse/","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"","category":"page"},{"location":"tutorials/collapse/","page":"Elasto-plastic large deformation","title":"Elasto-plastic large deformation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"info: Info\nStep-by-step instructions are provided after the code.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Tesserae\nimport Plots\n\nfunction main()\n\n    # Material constants\n    E  = 1000.0                 # Young's modulus\n    ν  = 0.3                    # Poisson's ratio\n    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame's first parameter\n    μ  = E / 2(1 + ν)           # Shear modulus\n    ρ⁰ = 1000.0                 # Initial density\n\n    # Grid and particle properties\n    GridProp = @NamedTuple begin\n        x  :: Vec{2, Float64} # Position\n        m  :: Float64         # Mass\n        mv :: Vec{2, Float64} # Momentum\n        f  :: Vec{2, Float64} # Force\n        v  :: Vec{2, Float64} # Velocity\n        vⁿ :: Vec{2, Float64} # Velocity at t = tⁿ\n    end\n    ParticleProp = @NamedTuple begin\n        x  :: Vec{2, Float64}                           # Position\n        m  :: Float64                                   # Mass\n        V⁰ :: Float64                                   # Initial volume\n        v  :: Vec{2, Float64}                           # Velocity\n        ∇v :: SecondOrderTensor{2, Float64, 4}          # Velocity gradient\n        F  :: SecondOrderTensor{2, Float64, 4}          # Deformation gradient\n        σ  :: SymmetricSecondOrderTensor{2, Float64, 3} # Cauchy stress\n    end\n\n    # Mesh\n    mesh = CartesianMesh(0.05, (0,1), (0,1))\n\n    # Background grid\n    grid = generate_grid(GridProp, mesh)\n\n    # Particles\n    particles = let\n        pts = generate_particles(ParticleProp, mesh; alg=GridSampling())\n        pts.V⁰ .= volume(mesh) / length(pts) # Set initial volume\n\n        # Left and right disks\n        r = 0.2 # Radius\n        lhs = findall(x -> norm(@. x-r    ) < r, pts.x)\n        rhs = findall(x -> norm(@. x-(1-r)) < r, pts.x)\n\n        # Set initial velocities\n        pts.v[lhs] .= Ref(Vec( 0.1, 0.1))\n        pts.v[rhs] .= Ref(Vec(-0.1,-0.1))\n\n        pts[[lhs; rhs]]\n    end\n    @. particles.m = ρ⁰ * particles.V⁰\n    @. particles.F = one(particles.F)\n\n    # Interpolation weights\n    weights = map(p -> InterpolationWeight(BSpline(Linear()), mesh), eachindex(particles))\n\n    # Create animation by `Plots.@gif`\n    Δt = 0.001\n    Plots.@gif for t in range(0, 4, step=Δt)\n\n        # Update basis function values\n        for p in eachindex(particles)\n            update!(weights[p], particles.x[p], mesh)\n        end\n\n        @P2G grid=>i particles=>p weights=>ip begin\n            m[i]  = @∑ w[ip] * m[p]\n            mv[i] = @∑ w[ip] * m[p] * v[p]\n            f[i]  = @∑ -V⁰[p] * det(F[p]) * σ[p] * ∇w[ip]\n        end\n\n        @. grid.vⁿ = grid.mv / grid.m\n        @. grid.v  = grid.vⁿ + (grid.f / grid.m) * Δt\n\n        @G2P grid=>i particles=>p weights=>ip begin\n            v[p] += @∑ w[ip] * (v[i] - vⁿ[i])\n            ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n            x[p] += @∑ w[ip] * v[i] * Δt\n        end\n\n        for p in eachindex(particles)\n            Δϵₚ = symmetric(particles.∇v[p]) * Δt\n            particles.F[p]  = (I + particles.∇v[p]*Δt) * particles.F[p]\n            particles.σ[p] += λ*tr(Δϵₚ)*I + 2μ*Δϵₚ # Linear elastic material\n        end\n\n        # Plot results\n        Plots.scatter(\n            reinterpret(Tuple{Float64,Float64}, particles.x),\n            lims = (0,1),\n            ticks = 0:0.2:1,\n            minorgrid = true,\n            minorticks = 4,\n            aspect_ratio = :equal,\n            legend = false,\n        )\n    end every 100\n\nend\n\nmain()","category":"page"},{"location":"tutorials/getting_started/#Grid-and-particle-generation","page":"Getting started","title":"Grid and particle generation","text":"","category":"section"},{"location":"tutorials/getting_started/#1.-Grid-and-particle-properties","page":"Getting started","title":"1. Grid and particle properties","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"E  = 500                    #hide\nν  = 0.3                    #hide\nλ  = (E*ν) / ((1+ν)*(1-2ν)) #hide\nμ  = E / 2(1 + ν)           #hide\nρ⁰ = 1000                   #hide\nnothing                     #hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Before generating grid and particles, we must define their properties. This can be done by simply defining a NamedTuple for the grid and particles, respectively, as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Tesserae # hide\nGridProp = @NamedTuple begin\n    x  :: Vec{2, Float64} # Position\n    m  :: Float64         # Mass\n    mv :: Vec{2, Float64} # Momentum\n    f  :: Vec{2, Float64} # Force\n    v  :: Vec{2, Float64} # Velocity\n    vⁿ :: Vec{2, Float64} # Velocity at t = tⁿ\nend\nParticleProp = @NamedTuple begin\n    x  :: Vec{2, Float64}                           # Position\n    m  :: Float64                                   # Mass\n    V⁰ :: Float64                                   # Initial volume\n    v  :: Vec{2, Float64}                           # Velocity\n    ∇v :: SecondOrderTensor{2, Float64, 4}          # Velocity gradient\n    F  :: SecondOrderTensor{2, Float64, 4}          # Deformation gradient\n    σ  :: SymmetricSecondOrderTensor{2, Float64, 3} # Cauchy stress\nend\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"These properties are fully customizable, allowing users to define any variables. However, two conditions must be met: (1) the property type must be of isbitstype, and (2) the first variable must represent the position of the grid nodes and particles. These position values are automatically set during the grid and particle generation process.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"isbitstype(GridProp)\nisbitstype(ParticleProp)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"info: Info\nThe struct can also be used instead of NamedTuple as follows:using Tesserae # hide\nstruct GridProp\n    x  :: Vec{2, Float64} # Position\n    m  :: Float64         # Mass\n    mv :: Vec{2, Float64} # Momentum\n    f  :: Vec{2, Float64} # Force\n    v  :: Vec{2, Float64} # Velocity\n    vⁿ :: Vec{2, Float64} # Velocity at t = tⁿ\nend","category":"page"},{"location":"tutorials/getting_started/#2.-Mesh-and-grid-generation","page":"Getting started","title":"2. Mesh and grid generation","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"In Tesserae, a mesh and a grid differ in that a mesh only contains information about the positions of the nodes, whereas a grid includes the mesh (i.e., nodal positions) and additional user-defined variables (as defined in GridProp above).","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To create Cartesian mesh, use CartesianMesh(spacing, (xmin, xmax), (ymin, ymax)...) as","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"mesh = CartesianMesh(0.05, (0,1), (0,1))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Using this mesh, the grid can be generated as","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"grid = generate_grid(GridProp, mesh)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This grid is a StructArray with an element type of GridProp. Thus, each variable defined in GridProp can be accessed using the . notation as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"grid.v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"info: Info\nNote that grid.x simply returns the mesh.grid.x === mesh","category":"page"},{"location":"tutorials/getting_started/#3.-Particle-generation","page":"Getting started","title":"3. Particle generation","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The particles can be generated using generate_particles function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"pts = generate_particles(ParticleProp, mesh; alg=GridSampling())","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This pts is also a StructArray, similar to grid.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"info: Info\nIn the generate_particles function, particles are generated across the entire mesh domain. Consequently, any unnecessary particles need to be removed.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"particles = let                                                      #hide\n    pts = generate_particles(ParticleProp, mesh; alg=GridSampling()) #hide\n    pts.V⁰ .= volume(mesh) / length(pts)                             #hide\n    r = 0.2                                                          #hide\n    lhs = findall(x -> norm(@. x-r    ) < r, pts.x)                  #hide\n    rhs = findall(x -> norm(@. x-(1-r)) < r, pts.x)                  #hide\n    pts.v[lhs] .= Ref(Vec( 0.1, 0.1))                                #hide\n    pts.v[rhs] .= Ref(Vec(-0.1,-0.1))                                #hide\n    pts[[lhs; rhs]]                                                  #hide\nend                                                                  #hide\nnothing                                                              #hide","category":"page"},{"location":"tutorials/getting_started/#Basis-function-values","page":"Getting started","title":"Basis function values","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"In Tesserae, the basis function values are stored in InterpolationWeight. For example, InterpolationWeight with the linear basis function can be constructed as","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"iw = InterpolationWeight(BSpline(Linear()), mesh)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This iw can be updated by passing the particle position to the update! function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"update!(iw, particles.x[1], mesh)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"info: Info\nAfter updating iw, you can check the partition of unity sum_i w_ip = 1:sum(iw.w)and the linear field reproduction sum_i w_ip bmx_i = bmx_p:nodeindices = neighboringnodes(iw)\nsum(eachindex(nodeindices)) do ip\n    i = nodeindices[ip]\n    iw.w[ip] * mesh[i]\nend","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"For the sake of performance, it's best to prepare the same number of InterpolationWeights as there are particles. This means that each particle has its own storage for the basis function values.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"weights = map(p -> InterpolationWeight(BSpline(Linear()), mesh), eachindex(particles))\nnothing #hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"info: Info\nIt is also possible to construct InterpolationWeights with Structure-Of-Arrays (SOA) layout using generate_interpolation_weights.weights = generate_interpolation_weights(BSpline(Linear()), mesh, length(particles))This SoA layout for InterpolationWeights is generally preferred for performance, although it cannot be resized.","category":"page"},{"location":"tutorials/getting_started/#Transfer-between-grid-and-particles","page":"Getting started","title":"Transfer between grid and particles","text":"","category":"section"},{"location":"tutorials/getting_started/#Particle-to-grid-transfer","page":"Getting started","title":"Particle-to-grid transfer","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Δt = 0.001                                     #hide\nfor p in eachindex(particles)                  #hide\n    update!(weights[p], particles.x[p], mesh) #hide\nend                                            #hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"For the particle-to-grid transfer, the @P2G macro is useful:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"@P2G grid=>i particles=>p weights=>ip begin\n    m[i]  = @∑ w[ip] * m[p]\n    mv[i] = @∑ w[ip] * m[p] * v[p]\n    f[i]  = @∑ -V⁰[p] * det(F[p]) * σ[p] * ∇w[ip]\nend","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This macro expands to roughly the following code:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"@. grid.m  = zero(grid.m)\n@. grid.mv = zero(grid.mv)\n@. grid.f  = zero(grid.f)\nfor p in eachindex(particles)\n    iw = weights[p]\n    nodeindices = neighboringnodes(iw)\n    for ip in eachindex(nodeindices)\n        i = nodeindices[ip]\n        grid.m[i]  += iw.w[ip] * particles.m[p]\n        grid.mv[i] += iw.w[ip] * particles.m[p] * particles.v[p]\n        grid.f[i]  += -particles.V⁰[p] * det(particles.F[p]) * particles.σ[p] * iw.∇w[ip]\n    end\nend","category":"page"},{"location":"tutorials/getting_started/#Grid-to-particle-transfer","page":"Getting started","title":"Grid-to-particle transfer","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Similar to the particle-to-grid transfer, the @G2P macro is provided for grid-to-particle transfer:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"@G2P grid=>i particles=>p weights=>ip begin\n    v[p] += @∑ w[ip] * (v[i] - vⁿ[i])\n    ∇v[p] = @∑ v[i] ⊗ ∇w[ip]\n    x[p] += @∑ w[ip] * v[i] * Δt\nend","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This macro expands to roughly the following code:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"for p in eachindex(particles)\n    iw = weights[p]\n    nodeindices = neighboringnodes(iw)\n    Δvₚ = zero(eltype(particles.v))\n    ∇vₚ = zero(eltype(particles.∇v))\n    Δxₚ = zero(eltype(particles.x))\n    for ip in eachindex(nodeindices)\n        i = nodeindices[ip]\n        Δvₚ += iw.w[ip] * (grid.v[i] - grid.vⁿ[i])\n        ∇vₚ += grid.v[i] ⊗ iw.∇w[ip]\n        Δxₚ += iw.w[ip] * grid.v[i] * Δt\n    end\n    particles.v[p] += Δvₚ\n    particles.∇v[p] = ∇vₚ\n    particles.x[p] += Δxₚ\nend","category":"page"},{"location":"#Tesserae.jl","page":"Home","title":"Tesserae.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia toolkit for the material point method","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tesserae is a toolkit for implementing the material point method in Julia. It is designed to maintain consistency between mathematical expressions and source code, enabling rapid development. Current features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid and particle generation\nVarious interpolation types, including B-splines, GIMP, CPDI, and MLS–MPM\nConvenient macros for transferring data between grid and particles\nMulti-threading support\nGPU support (CUDA and Metal)\nExporting VTK files for visualization\nUnified framework for FEM (experimental)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can add Tesserae using Julia's package manager, by typing ]add Tesserae in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Tesserae","category":"page"}]
}
