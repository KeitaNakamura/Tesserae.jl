<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · Tesserae.jl</title><meta name="title" content="Getting started · Tesserae.jl"/><meta property="og:title" content="Getting started · Tesserae.jl"/><meta property="twitter:title" content="Getting started · Tesserae.jl"/><meta name="description" content="Documentation for Tesserae.jl."/><meta property="og:description" content="Documentation for Tesserae.jl."/><meta property="twitter:description" content="Documentation for Tesserae.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Tesserae.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Grid-and-particle-generation"><span>Grid and particle generation</span></a></li><li><a class="tocitem" href="#Basis-function-values"><span>Basis function values</span></a></li><li><a class="tocitem" href="#Transfer-between-grid-and-particles"><span>Transfer between grid and particles</span></a></li></ul></li><li><a class="tocitem" href="../collision/">Transfer schemes</a></li><li><a class="tocitem" href="../cpdi/">CPDI</a></li><li><a class="tocitem" href="../tlmpm_vortex/">Total Lagrangian MPM</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Implicit methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../implicit/">Implicit formulation</a></li><li><a class="tocitem" href="../implicit_jacobian_free/">Jacobian-free</a></li><li><a class="tocitem" href="../implicit_jacobian_based/">Jacobian-based</a></li></ul></li><li><a class="tocitem" href="../collapse/">Elasto-plastic large deformation</a></li><li><a class="tocitem" href="../dam_break/">Incompressible fluid flow</a></li><li><a class="tocitem" href="../rigid_body_contact/">Frictional contact with rigid body</a></li><li><a class="tocitem" href="../taylor_impact/">Multi-threading simualtion</a></li><li><input class="collapse-toggle" id="menuitem-2-10" type="checkbox"/><label class="tocitem" for="menuitem-2-10"><span class="docs-label">FEM (experimental)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../heat/">Heat problem using FEM</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../mesh/">Mesh</a></li><li><a class="tocitem" href="../../generation/">Grid and particle generation</a></li><li><a class="tocitem" href="../../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../../transfer/">Transfer between grid and particles</a></li><li><a class="tocitem" href="../../implicit_utils/">Functionalities for implicit methods</a></li><li><a class="tocitem" href="../../multithreading/">Multi-threading</a></li><li><a class="tocitem" href="../../export/">Export</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/KeitaNakamura/Tesserae.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/KeitaNakamura/Tesserae.jl/blob/main/docs/src/tutorials/getting_started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h1><div class="admonition is-info" id="Info-69418ec6712f4a27"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-69418ec6712f4a27" title="Permalink"></a></header><div class="admonition-body"><p>Step-by-step instructions are provided after the code.</p></div></div><pre><code class="language-julia hljs">using Tesserae
import Plots

function main()

    # Material constants
    E  = 1000.0                 # Young&#39;s modulus
    ν  = 0.3                    # Poisson&#39;s ratio
    λ  = (E*ν) / ((1+ν)*(1-2ν)) # Lame&#39;s first parameter
    μ  = E / 2(1 + ν)           # Shear modulus
    ρ⁰ = 1000.0                 # Initial density

    # Grid and particle properties
    GridProp = @NamedTuple begin
        x  :: Vec{2, Float64} # Position
        m  :: Float64         # Mass
        mv :: Vec{2, Float64} # Momentum
        f  :: Vec{2, Float64} # Force
        v  :: Vec{2, Float64} # Velocity
        vⁿ :: Vec{2, Float64} # Velocity at t = tⁿ
    end
    ParticleProp = @NamedTuple begin
        x  :: Vec{2, Float64}                           # Position
        m  :: Float64                                   # Mass
        V⁰ :: Float64                                   # Initial volume
        v  :: Vec{2, Float64}                           # Velocity
        ∇v :: SecondOrderTensor{2, Float64, 4}          # Velocity gradient
        F  :: SecondOrderTensor{2, Float64, 4}          # Deformation gradient
        σ  :: SymmetricSecondOrderTensor{2, Float64, 3} # Cauchy stress
    end

    # Mesh
    mesh = CartesianMesh(0.05, (0,1), (0,1))

    # Background grid
    grid = generate_grid(GridProp, mesh)

    # Particles
    particles = let
        pts = generate_particles(ParticleProp, mesh; alg=GridSampling())
        pts.V⁰ .= volume(mesh) / length(pts) # Set initial volume

        # Left and right disks
        r = 0.2 # Radius
        lhs = findall(x -&gt; norm(@. x-r    ) &lt; r, pts.x)
        rhs = findall(x -&gt; norm(@. x-(1-r)) &lt; r, pts.x)

        # Set initial velocities
        pts.v[lhs] .= Ref(Vec( 0.1, 0.1))
        pts.v[rhs] .= Ref(Vec(-0.1,-0.1))

        pts[[lhs; rhs]]
    end
    @. particles.m = ρ⁰ * particles.V⁰
    @. particles.F = one(particles.F)

    # Interpolation weights
    weights = map(p -&gt; InterpolationWeight(BSpline(Linear()), mesh), eachindex(particles))

    # Create animation by `Plots.@gif`
    Δt = 0.001
    Plots.@gif for t in range(0, 4, step=Δt)

        # Update basis function values
        for p in eachindex(particles)
            update!(weights[p], particles.x[p], mesh)
        end

        @P2G grid=&gt;i particles=&gt;p weights=&gt;ip begin
            m[i]  = @∑ w[ip] * m[p]
            mv[i] = @∑ w[ip] * m[p] * v[p]
            f[i]  = @∑ -V⁰[p] * det(F[p]) * σ[p] * ∇w[ip]
        end

        @. grid.vⁿ = grid.mv / grid.m
        @. grid.v  = grid.vⁿ + (grid.f / grid.m) * Δt

        @G2P grid=&gt;i particles=&gt;p weights=&gt;ip begin
            v[p] += @∑ w[ip] * (v[i] - vⁿ[i])
            ∇v[p] = @∑ v[i] ⊗ ∇w[ip]
            x[p] += @∑ w[ip] * v[i] * Δt
        end

        for p in eachindex(particles)
            Δϵₚ = symmetric(particles.∇v[p]) * Δt
            particles.F[p]  = (I + particles.∇v[p]*Δt) * particles.F[p]
            particles.σ[p] += λ*tr(Δϵₚ)*I + 2μ*Δϵₚ # Linear elastic material
        end

        # Plot results
        Plots.scatter(
            reinterpret(Tuple{Float64,Float64}, particles.x),
            lims = (0,1),
            ticks = 0:0.2:1,
            minorgrid = true,
            minorticks = 4,
            aspect_ratio = :equal,
            legend = false,
        )
    end every 100

end

main()</code></pre><img src="24c5dfb6.gif" alt="Example block output"/><h2 id="Grid-and-particle-generation"><a class="docs-heading-anchor" href="#Grid-and-particle-generation">Grid and particle generation</a><a id="Grid-and-particle-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-and-particle-generation" title="Permalink"></a></h2><h3 id="1.-Grid-and-particle-properties"><a class="docs-heading-anchor" href="#1.-Grid-and-particle-properties">1. Grid and particle properties</a><a id="1.-Grid-and-particle-properties-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Grid-and-particle-properties" title="Permalink"></a></h3><p>Before generating grid and particles, we must define their properties. This can be done by simply defining a <code>NamedTuple</code> for the grid and particles, respectively, as follows:</p><pre><code class="language-julia hljs">GridProp = @NamedTuple begin
    x  :: Vec{2, Float64} # Position
    m  :: Float64         # Mass
    mv :: Vec{2, Float64} # Momentum
    f  :: Vec{2, Float64} # Force
    v  :: Vec{2, Float64} # Velocity
    vⁿ :: Vec{2, Float64} # Velocity at t = tⁿ
end
ParticleProp = @NamedTuple begin
    x  :: Vec{2, Float64}                           # Position
    m  :: Float64                                   # Mass
    V⁰ :: Float64                                   # Initial volume
    v  :: Vec{2, Float64}                           # Velocity
    ∇v :: SecondOrderTensor{2, Float64, 4}          # Velocity gradient
    F  :: SecondOrderTensor{2, Float64, 4}          # Deformation gradient
    σ  :: SymmetricSecondOrderTensor{2, Float64, 3} # Cauchy stress
end</code></pre><p>These properties are fully customizable, allowing users to define any variables. However, two conditions must be met: (1) the property type must be of <code>isbitstype</code>, and (2) the first variable must represent the position of the grid nodes and particles. These position values are automatically set during the grid and particle generation process.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; isbitstype(GridProp)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isbitstype(ParticleProp)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><div class="admonition is-info" id="Info-4c94fccb9eb28a15"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-4c94fccb9eb28a15" title="Permalink"></a></header><div class="admonition-body"><p>The <code>struct</code> can also be used instead of <code>NamedTuple</code> as follows:</p><pre><code class="language-julia hljs">struct GridProp
    x  :: Vec{2, Float64} # Position
    m  :: Float64         # Mass
    mv :: Vec{2, Float64} # Momentum
    f  :: Vec{2, Float64} # Force
    v  :: Vec{2, Float64} # Velocity
    vⁿ :: Vec{2, Float64} # Velocity at t = tⁿ
end</code></pre></div></div><h3 id="2.-Mesh-and-grid-generation"><a class="docs-heading-anchor" href="#2.-Mesh-and-grid-generation">2. Mesh and grid generation</a><a id="2.-Mesh-and-grid-generation-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Mesh-and-grid-generation" title="Permalink"></a></h3><p>In Tesserae, a mesh and a grid differ in that a mesh only contains information about the positions of the nodes, whereas a grid includes the mesh (i.e., nodal positions) and additional user-defined variables (as defined in <code>GridProp</code> above).</p><p>To create Cartesian mesh, use <code>CartesianMesh(spacing, (xmin, xmax), (ymin, ymax)...)</code> as</p><pre><code class="language-julia hljs">mesh = CartesianMesh(0.05, (0,1), (0,1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">21×21 CartesianMesh{2, Float64, Vector{Float64}}:
 [0.0, 0.0]   [0.0, 0.05]   [0.0, 0.1]   …  [0.0, 0.95]   [0.0, 1.0]
 [0.05, 0.0]  [0.05, 0.05]  [0.05, 0.1]     [0.05, 0.95]  [0.05, 1.0]
 [0.1, 0.0]   [0.1, 0.05]   [0.1, 0.1]      [0.1, 0.95]   [0.1, 1.0]
 [0.15, 0.0]  [0.15, 0.05]  [0.15, 0.1]     [0.15, 0.95]  [0.15, 1.0]
 [0.2, 0.0]   [0.2, 0.05]   [0.2, 0.1]      [0.2, 0.95]   [0.2, 1.0]
 [0.25, 0.0]  [0.25, 0.05]  [0.25, 0.1]  …  [0.25, 0.95]  [0.25, 1.0]
 [0.3, 0.0]   [0.3, 0.05]   [0.3, 0.1]      [0.3, 0.95]   [0.3, 1.0]
 [0.35, 0.0]  [0.35, 0.05]  [0.35, 0.1]     [0.35, 0.95]  [0.35, 1.0]
 [0.4, 0.0]   [0.4, 0.05]   [0.4, 0.1]      [0.4, 0.95]   [0.4, 1.0]
 [0.45, 0.0]  [0.45, 0.05]  [0.45, 0.1]     [0.45, 0.95]  [0.45, 1.0]
 ⋮                                       ⋱                ⋮
 [0.6, 0.0]   [0.6, 0.05]   [0.6, 0.1]      [0.6, 0.95]   [0.6, 1.0]
 [0.65, 0.0]  [0.65, 0.05]  [0.65, 0.1]     [0.65, 0.95]  [0.65, 1.0]
 [0.7, 0.0]   [0.7, 0.05]   [0.7, 0.1]      [0.7, 0.95]   [0.7, 1.0]
 [0.75, 0.0]  [0.75, 0.05]  [0.75, 0.1]  …  [0.75, 0.95]  [0.75, 1.0]
 [0.8, 0.0]   [0.8, 0.05]   [0.8, 0.1]      [0.8, 0.95]   [0.8, 1.0]
 [0.85, 0.0]  [0.85, 0.05]  [0.85, 0.1]     [0.85, 0.95]  [0.85, 1.0]
 [0.9, 0.0]   [0.9, 0.05]   [0.9, 0.1]      [0.9, 0.95]   [0.9, 1.0]
 [0.95, 0.0]  [0.95, 0.05]  [0.95, 0.1]     [0.95, 0.95]  [0.95, 1.0]
 [1.0, 0.0]   [1.0, 0.05]   [1.0, 0.1]   …  [1.0, 0.95]   [1.0, 1.0]</code></pre><p>Using this <code>mesh</code>, the grid can be generated as</p><pre><code class="language-julia hljs">grid = generate_grid(GridProp, mesh)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">21×21 StructArray(::CartesianMesh{2, Float64, Vector{Float64}}, ::Matrix{Float64}, ::Matrix{Vec{2, Float64}}, ::Matrix{Vec{2, Float64}}, ::Matrix{Vec{2, Float64}}, ::Matrix{Vec{2, Float64}}) with eltype @NamedTuple{x::Vec{2, Float64}, m::Float64, mv::Vec{2, Float64}, f::Vec{2, Float64}, v::Vec{2, Float64}, vⁿ::Vec{2, Float64}}:
 (x = [0.0, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])   …  (x = [0.0, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.05, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.05, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.1, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.1, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.15, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.15, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.2, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.2, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.25, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])  …  (x = [0.25, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.3, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.3, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.35, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.35, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.4, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.4, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.45, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.45, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 ⋮                                                                                             ⋱  ⋮
 (x = [0.6, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.6, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.65, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.65, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.7, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.7, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.75, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])  …  (x = [0.75, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.8, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.8, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.85, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.85, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.9, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])      (x = [0.9, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [0.95, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])     (x = [0.95, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])
 (x = [1.0, 0.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])   …  (x = [1.0, 1.0], m = 0.0, mv = [0.0, 0.0], f = [0.0, 0.0], v = [0.0, 0.0], vⁿ = [0.0, 0.0])</code></pre><p>This <code>grid</code> is a <a href="https://github.com/JuliaArrays/StructArrays.jl"><code>StructArray</code></a> with an element type of <code>GridProp</code>. Thus, each variable defined in <code>GridProp</code> can be accessed using the <code>.</code> notation as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; grid.v</code><code class="nohighlight hljs ansi" style="display:block;">21×21 Matrix{Vec{2, Float64}}:
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  …  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  …  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 ⋮                                   ⋱                          ⋮
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  …  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]     [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]
 [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]  …  [0.0, 0.0]  [0.0, 0.0]  [0.0, 0.0]</code></pre><div class="admonition is-info" id="Info-755f12af5a753856"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-755f12af5a753856" title="Permalink"></a></header><div class="admonition-body"><p>Note that <code>grid.x</code> simply returns the mesh.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; grid.x === mesh</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre></div></div><h3 id="3.-Particle-generation"><a class="docs-heading-anchor" href="#3.-Particle-generation">3. Particle generation</a><a id="3.-Particle-generation-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Particle-generation" title="Permalink"></a></h3><p>The particles can be generated using <code>generate_particles</code> function:</p><pre><code class="language-julia hljs">pts = generate_particles(ParticleProp, mesh; alg=GridSampling())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1600-element StructArray(::Vector{Vec{2, Float64}}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Vec{2, Float64}}, ::Vector{Tensor{Tuple{2, 2}, Float64, 2, 4}}, ::Vector{Tensor{Tuple{2, 2}, Float64, 2, 4}}, ::Vector{SymmetricSecondOrderTensor{2, Float64, 3}}) with eltype @NamedTuple{x::Vec{2, Float64}, m::Float64, V⁰::Float64, v::Vec{2, Float64}, ∇v::Tensor{Tuple{2, 2}, Float64, 2, 4}, F::Tensor{Tuple{2, 2}, Float64, 2, 4}, σ::SymmetricSecondOrderTensor{2, Float64, 3}}:
 (x = [0.0125, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.0375, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.0625, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.0875, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.1125, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.1375, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.1625, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.1875, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.2125, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.2375, 0.0125], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 ⋮
 (x = [0.7875, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.8125, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.8375, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.8625, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.8875, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.9125, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.9375, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.9625, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])
 (x = [0.9875, 0.9875], m = 0.0, V⁰ = 0.0, v = [0.0, 0.0], ∇v = [0.0 0.0; 0.0 0.0], F = [0.0 0.0; 0.0 0.0], σ = [0.0 0.0; 0.0 0.0])</code></pre><p>This <code>pts</code> is also a <a href="https://github.com/JuliaArrays/StructArrays.jl"><code>StructArray</code></a>, similar to <code>grid</code>.</p><div class="admonition is-info" id="Info-4622c84a59d37ee2"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-4622c84a59d37ee2" title="Permalink"></a></header><div class="admonition-body"><p>In the <code>generate_particles</code> function, particles are generated across the entire <code>mesh</code> domain. Consequently, any unnecessary particles need to be removed.</p></div></div><h2 id="Basis-function-values"><a class="docs-heading-anchor" href="#Basis-function-values">Basis function values</a><a id="Basis-function-values-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-function-values" title="Permalink"></a></h2><p>In Tesserae, the basis function values are stored in <code>InterpolationWeight</code>. For example, <code>InterpolationWeight</code> with the linear basis function can be constructed as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; iw = InterpolationWeight(BSpline(Linear()), mesh)</code><code class="nohighlight hljs ansi" style="display:block;">InterpolationWeight:
  Interpolation: BSpline(Linear())
  Property names: w::Matrix{Float64}, ∇w::Matrix{Vec{2, Float64}}
  Neighboring nodes: CartesianIndices((1:0, 1:0))</code></pre><p>This <code>iw</code> can be updated by passing the particle position to the <code>update!</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; update!(iw, particles.x[1], mesh)</code><code class="nohighlight hljs ansi" style="display:block;">InterpolationWeight:
  Interpolation: BSpline(Linear())
  Property names: w::Matrix{Float64}, ∇w::Matrix{Vec{2, Float64}}
  Neighboring nodes: CartesianIndices((3:4, 1:2))</code></pre><div class="admonition is-info" id="Info-60590243f95072f0"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-60590243f95072f0" title="Permalink"></a></header><div class="admonition-body"><p>After updating <code>iw</code>, you can check the partition of unity <span>$\sum_i w_{ip} = 1$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(iw.w)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code></pre><p>and the linear field reproduction <span>$\sum_i w_{ip} \bm{x}_i = \bm{x}_p$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nodeindices = neighboringnodes(iw)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianIndices((3:4, 1:2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(eachindex(nodeindices)) do ip
           i = nodeindices[ip]
           iw.w[ip] * mesh[i]
       end</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vec{2, Float64}:
 0.1375
 0.0125</code></pre></div></div><p>For the sake of performance, it&#39;s best to prepare the same number of <code>InterpolationWeight</code>s as there are particles. This means that each particle has its own storage for the basis function values.</p><pre><code class="language-julia hljs">weights = map(p -&gt; InterpolationWeight(BSpline(Linear()), mesh), eachindex(particles))</code></pre><div class="admonition is-info" id="Info-289a7a87b182b889"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-289a7a87b182b889" title="Permalink"></a></header><div class="admonition-body"><p>It is also possible to construct <code>InterpolationWeight</code>s with Structure-Of-Arrays (SOA) layout using <code>generate_interpolation_weights</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; weights = generate_interpolation_weights(BSpline(Linear()), mesh, length(particles))</code><code class="nohighlight hljs ansi" style="display:block;">416-element InterpolationWeightVector:
  Interpolation: BSpline(Linear())
  Property names: w, ∇w</code></pre><p>This SoA layout for <code>InterpolationWeight</code>s is generally preferred for performance, although it cannot be resized.</p></div></div><h2 id="Transfer-between-grid-and-particles"><a class="docs-heading-anchor" href="#Transfer-between-grid-and-particles">Transfer between grid and particles</a><a id="Transfer-between-grid-and-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Transfer-between-grid-and-particles" title="Permalink"></a></h2><h3 id="Particle-to-grid-transfer"><a class="docs-heading-anchor" href="#Particle-to-grid-transfer">Particle-to-grid transfer</a><a id="Particle-to-grid-transfer-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-to-grid-transfer" title="Permalink"></a></h3><p>For the particle-to-grid transfer, the <a href="../../transfer/#Tesserae.@P2G"><code>@P2G</code></a> macro is useful:</p><pre><code class="language-julia hljs">@P2G grid=&gt;i particles=&gt;p weights=&gt;ip begin
    m[i]  = @∑ w[ip] * m[p]
    mv[i] = @∑ w[ip] * m[p] * v[p]
    f[i]  = @∑ -V⁰[p] * det(F[p]) * σ[p] * ∇w[ip]
end</code></pre><p>This macro expands to roughly the following code:</p><pre><code class="language-julia hljs">@. grid.m  = zero(grid.m)
@. grid.mv = zero(grid.mv)
@. grid.f  = zero(grid.f)
for p in eachindex(particles)
    iw = weights[p]
    nodeindices = neighboringnodes(iw)
    for ip in eachindex(nodeindices)
        i = nodeindices[ip]
        grid.m[i]  += iw.w[ip] * particles.m[p]
        grid.mv[i] += iw.w[ip] * particles.m[p] * particles.v[p]
        grid.f[i]  += -particles.V⁰[p] * det(particles.F[p]) * particles.σ[p] * iw.∇w[ip]
    end
end</code></pre><h3 id="Grid-to-particle-transfer"><a class="docs-heading-anchor" href="#Grid-to-particle-transfer">Grid-to-particle transfer</a><a id="Grid-to-particle-transfer-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-to-particle-transfer" title="Permalink"></a></h3><p>Similar to the particle-to-grid transfer, the <a href="../../transfer/#Tesserae.@G2P"><code>@G2P</code></a> macro is provided for grid-to-particle transfer:</p><pre><code class="language-julia hljs">@G2P grid=&gt;i particles=&gt;p weights=&gt;ip begin
    v[p] += @∑ w[ip] * (v[i] - vⁿ[i])
    ∇v[p] = @∑ v[i] ⊗ ∇w[ip]
    x[p] += @∑ w[ip] * v[i] * Δt
end</code></pre><p>This macro expands to roughly the following code:</p><pre><code class="language-julia hljs">for p in eachindex(particles)
    iw = weights[p]
    nodeindices = neighboringnodes(iw)
    Δvₚ = zero(eltype(particles.v))
    ∇vₚ = zero(eltype(particles.∇v))
    Δxₚ = zero(eltype(particles.x))
    for ip in eachindex(nodeindices)
        i = nodeindices[ip]
        Δvₚ += iw.w[ip] * (grid.v[i] - grid.vⁿ[i])
        ∇vₚ += grid.v[i] ⊗ iw.∇w[ip]
        Δxₚ += iw.w[ip] * grid.v[i] * Δt
    end
    particles.v[p] += Δvₚ
    particles.∇v[p] = ∇vₚ
    particles.x[p] += Δxₚ
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../collision/">Transfer schemes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 26 July 2025 13:29">Saturday 26 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
